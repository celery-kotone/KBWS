/* soapC.c
   Generated by gSOAP 2.7.13 from kbws.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.7.13 2010-11-16 12:53:02 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header));
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__getMultiResult:
		return soap_in_ns1__getMultiResult(soap, NULL, NULL, "ns1:getMultiResult");
	case SOAP_TYPE_ns1__getMultiResultResponse:
		return soap_in_ns1__getMultiResultResponse(soap, NULL, NULL, "ns1:getMultiResultResponse");
	case SOAP_TYPE_ns1__getResult:
		return soap_in_ns1__getResult(soap, NULL, NULL, "ns1:getResult");
	case SOAP_TYPE_ns1__getResultResponse:
		return soap_in_ns1__getResultResponse(soap, NULL, NULL, "ns1:getResultResponse");
	case SOAP_TYPE_ns1__checkStatus_USCOREretJobid:
		return soap_in_ns1__checkStatus_USCOREretJobid(soap, NULL, NULL, "ns1:checkStatus_retJobid");
	case SOAP_TYPE_ns1__checkStatus_USCOREretJobidResponse:
		return soap_in_ns1__checkStatus_USCOREretJobidResponse(soap, NULL, NULL, "ns1:checkStatus_retJobidResponse");
	case SOAP_TYPE_ns1__checkStatus:
		return soap_in_ns1__checkStatus(soap, NULL, NULL, "ns1:checkStatus");
	case SOAP_TYPE_ns1__checkStatusResponse:
		return soap_in_ns1__checkStatusResponse(soap, NULL, NULL, "ns1:checkStatusResponse");
	case SOAP_TYPE_ns1__map2PathwayProjector:
		return soap_in_ns1__map2PathwayProjector(soap, NULL, NULL, "ns1:map2PathwayProjector");
	case SOAP_TYPE_ns1__map2PathwayProjectorResponse:
		return soap_in_ns1__map2PathwayProjectorResponse(soap, NULL, NULL, "ns1:map2PathwayProjectorResponse");
	case SOAP_TYPE_ns1__showBlastDB:
		return soap_in_ns1__showBlastDB(soap, NULL, NULL, "ns1:showBlastDB");
	case SOAP_TYPE_ns1__showBlastDBResponse:
		return soap_in_ns1__showBlastDBResponse(soap, NULL, NULL, "ns1:showBlastDBResponse");
	case SOAP_TYPE_ns1__runRNAfold:
		return soap_in_ns1__runRNAfold(soap, NULL, NULL, "ns1:runRNAfold");
	case SOAP_TYPE_ns1__runRNAfoldResponse:
		return soap_in_ns1__runRNAfoldResponse(soap, NULL, NULL, "ns1:runRNAfoldResponse");
	case SOAP_TYPE_ns1__runWolfPsort:
		return soap_in_ns1__runWolfPsort(soap, NULL, NULL, "ns1:runWolfPsort");
	case SOAP_TYPE_ns1__runWolfPsortResponse:
		return soap_in_ns1__runWolfPsortResponse(soap, NULL, NULL, "ns1:runWolfPsortResponse");
	case SOAP_TYPE_ns1__runWeblogo:
		return soap_in_ns1__runWeblogo(soap, NULL, NULL, "ns1:runWeblogo");
	case SOAP_TYPE_ns1__runWeblogoResponse:
		return soap_in_ns1__runWeblogoResponse(soap, NULL, NULL, "ns1:runWeblogoResponse");
	case SOAP_TYPE_ns1__runtRNAscan:
		return soap_in_ns1__runtRNAscan(soap, NULL, NULL, "ns1:runtRNAscan");
	case SOAP_TYPE_ns1__runtRNAscanResponse:
		return soap_in_ns1__runtRNAscanResponse(soap, NULL, NULL, "ns1:runtRNAscanResponse");
	case SOAP_TYPE_ns1__runTcoffee:
		return soap_in_ns1__runTcoffee(soap, NULL, NULL, "ns1:runTcoffee");
	case SOAP_TYPE_ns1__runTcoffeeResponse:
		return soap_in_ns1__runTcoffeeResponse(soap, NULL, NULL, "ns1:runTcoffeeResponse");
	case SOAP_TYPE_ns1__runSsearch:
		return soap_in_ns1__runSsearch(soap, NULL, NULL, "ns1:runSsearch");
	case SOAP_TYPE_ns1__runSsearchResponse:
		return soap_in_ns1__runSsearchResponse(soap, NULL, NULL, "ns1:runSsearchResponse");
	case SOAP_TYPE_ns1__runPsortb:
		return soap_in_ns1__runPsortb(soap, NULL, NULL, "ns1:runPsortb");
	case SOAP_TYPE_ns1__runPsortbResponse:
		return soap_in_ns1__runPsortbResponse(soap, NULL, NULL, "ns1:runPsortbResponse");
	case SOAP_TYPE_ns1__runPsort2:
		return soap_in_ns1__runPsort2(soap, NULL, NULL, "ns1:runPsort2");
	case SOAP_TYPE_ns1__runPsort2Response:
		return soap_in_ns1__runPsort2Response(soap, NULL, NULL, "ns1:runPsort2Response");
	case SOAP_TYPE_ns1__runPsort:
		return soap_in_ns1__runPsort(soap, NULL, NULL, "ns1:runPsort");
	case SOAP_TYPE_ns1__runPsortResponse:
		return soap_in_ns1__runPsortResponse(soap, NULL, NULL, "ns1:runPsortResponse");
	case SOAP_TYPE_ns1__runDolpenny:
		return soap_in_ns1__runDolpenny(soap, NULL, NULL, "ns1:runDolpenny");
	case SOAP_TYPE_ns1__runDolpennyResponse:
		return soap_in_ns1__runDolpennyResponse(soap, NULL, NULL, "ns1:runDolpennyResponse");
	case SOAP_TYPE_ns1__runDollop:
		return soap_in_ns1__runDollop(soap, NULL, NULL, "ns1:runDollop");
	case SOAP_TYPE_ns1__runDollopResponse:
		return soap_in_ns1__runDollopResponse(soap, NULL, NULL, "ns1:runDollopResponse");
	case SOAP_TYPE_ns1__runPenny:
		return soap_in_ns1__runPenny(soap, NULL, NULL, "ns1:runPenny");
	case SOAP_TYPE_ns1__runPennyResponse:
		return soap_in_ns1__runPennyResponse(soap, NULL, NULL, "ns1:runPennyResponse");
	case SOAP_TYPE_ns1__runMix:
		return soap_in_ns1__runMix(soap, NULL, NULL, "ns1:runMix");
	case SOAP_TYPE_ns1__runMixResponse:
		return soap_in_ns1__runMixResponse(soap, NULL, NULL, "ns1:runMixResponse");
	case SOAP_TYPE_ns1__runContml:
		return soap_in_ns1__runContml(soap, NULL, NULL, "ns1:runContml");
	case SOAP_TYPE_ns1__runContmlResponse:
		return soap_in_ns1__runContmlResponse(soap, NULL, NULL, "ns1:runContmlResponse");
	case SOAP_TYPE_ns1__runNeighbor:
		return soap_in_ns1__runNeighbor(soap, NULL, NULL, "ns1:runNeighbor");
	case SOAP_TYPE_ns1__runNeighborResponse:
		return soap_in_ns1__runNeighborResponse(soap, NULL, NULL, "ns1:runNeighborResponse");
	case SOAP_TYPE_ns1__runKitsch:
		return soap_in_ns1__runKitsch(soap, NULL, NULL, "ns1:runKitsch");
	case SOAP_TYPE_ns1__runKitschResponse:
		return soap_in_ns1__runKitschResponse(soap, NULL, NULL, "ns1:runKitschResponse");
	case SOAP_TYPE_ns1__runFitch:
		return soap_in_ns1__runFitch(soap, NULL, NULL, "ns1:runFitch");
	case SOAP_TYPE_ns1__runFitchResponse:
		return soap_in_ns1__runFitchResponse(soap, NULL, NULL, "ns1:runFitchResponse");
	case SOAP_TYPE_ns1__runClique:
		return soap_in_ns1__runClique(soap, NULL, NULL, "ns1:runClique");
	case SOAP_TYPE_ns1__runCliqueResponse:
		return soap_in_ns1__runCliqueResponse(soap, NULL, NULL, "ns1:runCliqueResponse");
	case SOAP_TYPE_ns1__runRestml:
		return soap_in_ns1__runRestml(soap, NULL, NULL, "ns1:runRestml");
	case SOAP_TYPE_ns1__runRestmlResponse:
		return soap_in_ns1__runRestmlResponse(soap, NULL, NULL, "ns1:runRestmlResponse");
	case SOAP_TYPE_ns1__runSeqboot:
		return soap_in_ns1__runSeqboot(soap, NULL, NULL, "ns1:runSeqboot");
	case SOAP_TYPE_ns1__runSeqbootResponse:
		return soap_in_ns1__runSeqbootResponse(soap, NULL, NULL, "ns1:runSeqbootResponse");
	case SOAP_TYPE_ns1__runGendist:
		return soap_in_ns1__runGendist(soap, NULL, NULL, "ns1:runGendist");
	case SOAP_TYPE_ns1__runGendistResponse:
		return soap_in_ns1__runGendistResponse(soap, NULL, NULL, "ns1:runGendistResponse");
	case SOAP_TYPE_ns1__runDnadist:
		return soap_in_ns1__runDnadist(soap, NULL, NULL, "ns1:runDnadist");
	case SOAP_TYPE_ns1__runDnadistResponse:
		return soap_in_ns1__runDnadistResponse(soap, NULL, NULL, "ns1:runDnadistResponse");
	case SOAP_TYPE_ns1__runDnamlk:
		return soap_in_ns1__runDnamlk(soap, NULL, NULL, "ns1:runDnamlk");
	case SOAP_TYPE_ns1__runDnamlkResponse:
		return soap_in_ns1__runDnamlkResponse(soap, NULL, NULL, "ns1:runDnamlkResponse");
	case SOAP_TYPE_ns1__runDnaml:
		return soap_in_ns1__runDnaml(soap, NULL, NULL, "ns1:runDnaml");
	case SOAP_TYPE_ns1__runDnamlResponse:
		return soap_in_ns1__runDnamlResponse(soap, NULL, NULL, "ns1:runDnamlResponse");
	case SOAP_TYPE_ns1__runDnainvar:
		return soap_in_ns1__runDnainvar(soap, NULL, NULL, "ns1:runDnainvar");
	case SOAP_TYPE_ns1__runDnainvarResponse:
		return soap_in_ns1__runDnainvarResponse(soap, NULL, NULL, "ns1:runDnainvarResponse");
	case SOAP_TYPE_ns1__runDnacomp:
		return soap_in_ns1__runDnacomp(soap, NULL, NULL, "ns1:runDnacomp");
	case SOAP_TYPE_ns1__runDnacompResponse:
		return soap_in_ns1__runDnacompResponse(soap, NULL, NULL, "ns1:runDnacompResponse");
	case SOAP_TYPE_ns1__runDnapenny:
		return soap_in_ns1__runDnapenny(soap, NULL, NULL, "ns1:runDnapenny");
	case SOAP_TYPE_ns1__runDnapennyResponse:
		return soap_in_ns1__runDnapennyResponse(soap, NULL, NULL, "ns1:runDnapennyResponse");
	case SOAP_TYPE_ns1__runDnapars:
		return soap_in_ns1__runDnapars(soap, NULL, NULL, "ns1:runDnapars");
	case SOAP_TYPE_ns1__runDnaparsResponse:
		return soap_in_ns1__runDnaparsResponse(soap, NULL, NULL, "ns1:runDnaparsResponse");
	case SOAP_TYPE_ns1__runProtdist:
		return soap_in_ns1__runProtdist(soap, NULL, NULL, "ns1:runProtdist");
	case SOAP_TYPE_ns1__runProtdistResponse:
		return soap_in_ns1__runProtdistResponse(soap, NULL, NULL, "ns1:runProtdistResponse");
	case SOAP_TYPE_ns1__runProtpars:
		return soap_in_ns1__runProtpars(soap, NULL, NULL, "ns1:runProtpars");
	case SOAP_TYPE_ns1__runProtparsResponse:
		return soap_in_ns1__runProtparsResponse(soap, NULL, NULL, "ns1:runProtparsResponse");
	case SOAP_TYPE_ns1__runPhobius:
		return soap_in_ns1__runPhobius(soap, NULL, NULL, "ns1:runPhobius");
	case SOAP_TYPE_ns1__runPhobiusResponse:
		return soap_in_ns1__runPhobiusResponse(soap, NULL, NULL, "ns1:runPhobiusResponse");
	case SOAP_TYPE_ns1__runMuscle:
		return soap_in_ns1__runMuscle(soap, NULL, NULL, "ns1:runMuscle");
	case SOAP_TYPE_ns1__runMuscleResponse:
		return soap_in_ns1__runMuscleResponse(soap, NULL, NULL, "ns1:runMuscleResponse");
	case SOAP_TYPE_ns1__runMafft:
		return soap_in_ns1__runMafft(soap, NULL, NULL, "ns1:runMafft");
	case SOAP_TYPE_ns1__runMafftResponse:
		return soap_in_ns1__runMafftResponse(soap, NULL, NULL, "ns1:runMafftResponse");
	case SOAP_TYPE_ns1__runKalign:
		return soap_in_ns1__runKalign(soap, NULL, NULL, "ns1:runKalign");
	case SOAP_TYPE_ns1__runKalignResponse:
		return soap_in_ns1__runKalignResponse(soap, NULL, NULL, "ns1:runKalignResponse");
	case SOAP_TYPE_ns1__runGlimmer:
		return soap_in_ns1__runGlimmer(soap, NULL, NULL, "ns1:runGlimmer");
	case SOAP_TYPE_ns1__runGlimmerResponse:
		return soap_in_ns1__runGlimmerResponse(soap, NULL, NULL, "ns1:runGlimmerResponse");
	case SOAP_TYPE_ns1__runGenemarkhmm:
		return soap_in_ns1__runGenemarkhmm(soap, NULL, NULL, "ns1:runGenemarkhmm");
	case SOAP_TYPE_ns1__runGenemarkhmmResponse:
		return soap_in_ns1__runGenemarkhmmResponse(soap, NULL, NULL, "ns1:runGenemarkhmmResponse");
	case SOAP_TYPE_ns1__runFetchBatch:
		return soap_in_ns1__runFetchBatch(soap, NULL, NULL, "ns1:runFetchBatch");
	case SOAP_TYPE_ns1__runFetchBatchResponse:
		return soap_in_ns1__runFetchBatchResponse(soap, NULL, NULL, "ns1:runFetchBatchResponse");
	case SOAP_TYPE_ns1__runFetchData:
		return soap_in_ns1__runFetchData(soap, NULL, NULL, "ns1:runFetchData");
	case SOAP_TYPE_ns1__runFetchDataResponse:
		return soap_in_ns1__runFetchDataResponse(soap, NULL, NULL, "ns1:runFetchDataResponse");
	case SOAP_TYPE_ns1__runClustalw:
		return soap_in_ns1__runClustalw(soap, NULL, NULL, "ns1:runClustalw");
	case SOAP_TYPE_ns1__runClustalwResponse:
		return soap_in_ns1__runClustalwResponse(soap, NULL, NULL, "ns1:runClustalwResponse");
	case SOAP_TYPE_ns1__runCentroidfold:
		return soap_in_ns1__runCentroidfold(soap, NULL, NULL, "ns1:runCentroidfold");
	case SOAP_TYPE_ns1__runCentroidfoldResponse:
		return soap_in_ns1__runCentroidfoldResponse(soap, NULL, NULL, "ns1:runCentroidfoldResponse");
	case SOAP_TYPE_ns1__runBlast:
		return soap_in_ns1__runBlast(soap, NULL, NULL, "ns1:runBlast");
	case SOAP_TYPE_ns1__runBlastResponse:
		return soap_in_ns1__runBlastResponse(soap, NULL, NULL, "ns1:runBlastResponse");
	case SOAP_TYPE_ns1__showBlastDBInputParams:
		return soap_in_ns1__showBlastDBInputParams(soap, NULL, NULL, "ns1:showBlastDBInputParams");
	case SOAP_TYPE_ns1__RNAfoldInputParams:
		return soap_in_ns1__RNAfoldInputParams(soap, NULL, NULL, "ns1:RNAfoldInputParams");
	case SOAP_TYPE_ns1__wolfPsortInputParams:
		return soap_in_ns1__wolfPsortInputParams(soap, NULL, NULL, "ns1:wolfPsortInputParams");
	case SOAP_TYPE_ns1__weblogoInputParams:
		return soap_in_ns1__weblogoInputParams(soap, NULL, NULL, "ns1:weblogoInputParams");
	case SOAP_TYPE_ns1__ssearchInputParams:
		return soap_in_ns1__ssearchInputParams(soap, NULL, NULL, "ns1:ssearchInputParams");
	case SOAP_TYPE_ns1__tRNAscanInputParams:
		return soap_in_ns1__tRNAscanInputParams(soap, NULL, NULL, "ns1:tRNAscanInputParams");
	case SOAP_TYPE_ns1__tcoffeeInputParams:
		return soap_in_ns1__tcoffeeInputParams(soap, NULL, NULL, "ns1:tcoffeeInputParams");
	case SOAP_TYPE_ns1__psortbInputParams:
		return soap_in_ns1__psortbInputParams(soap, NULL, NULL, "ns1:psortbInputParams");
	case SOAP_TYPE_ns1__psortInputParams:
		return soap_in_ns1__psortInputParams(soap, NULL, NULL, "ns1:psortInputParams");
	case SOAP_TYPE_ns1__phobiusInputParams:
		return soap_in_ns1__phobiusInputParams(soap, NULL, NULL, "ns1:phobiusInputParams");
	case SOAP_TYPE_ns1__muscleInputParams:
		return soap_in_ns1__muscleInputParams(soap, NULL, NULL, "ns1:muscleInputParams");
	case SOAP_TYPE_ns1__mafftInputParams:
		return soap_in_ns1__mafftInputParams(soap, NULL, NULL, "ns1:mafftInputParams");
	case SOAP_TYPE_ns1__kalignInputParams:
		return soap_in_ns1__kalignInputParams(soap, NULL, NULL, "ns1:kalignInputParams");
	case SOAP_TYPE_ns1__glimmerInputParams:
		return soap_in_ns1__glimmerInputParams(soap, NULL, NULL, "ns1:glimmerInputParams");
	case SOAP_TYPE_ns1__genemarkhmmInputParams:
		return soap_in_ns1__genemarkhmmInputParams(soap, NULL, NULL, "ns1:genemarkhmmInputParams");
	case SOAP_TYPE_ns1__fetchBatchInputParams:
		return soap_in_ns1__fetchBatchInputParams(soap, NULL, NULL, "ns1:fetchBatchInputParams");
	case SOAP_TYPE_ns1__fetchDataInputParams:
		return soap_in_ns1__fetchDataInputParams(soap, NULL, NULL, "ns1:fetchDataInputParams");
	case SOAP_TYPE_ns1__clustalwInputParams:
		return soap_in_ns1__clustalwInputParams(soap, NULL, NULL, "ns1:clustalwInputParams");
	case SOAP_TYPE_ns1__centroidfoldInputParams:
		return soap_in_ns1__centroidfoldInputParams(soap, NULL, NULL, "ns1:centroidfoldInputParams");
	case SOAP_TYPE_ns1__blastInputParams:
		return soap_in_ns1__blastInputParams(soap, NULL, NULL, "ns1:blastInputParams");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTons1__showBlastDBInputParams:
		return soap_in_PointerTons1__showBlastDBInputParams(soap, NULL, NULL, "ns1:showBlastDBInputParams");
	case SOAP_TYPE_PointerTons1__RNAfoldInputParams:
		return soap_in_PointerTons1__RNAfoldInputParams(soap, NULL, NULL, "ns1:RNAfoldInputParams");
	case SOAP_TYPE_PointerTons1__wolfPsortInputParams:
		return soap_in_PointerTons1__wolfPsortInputParams(soap, NULL, NULL, "ns1:wolfPsortInputParams");
	case SOAP_TYPE_PointerTons1__weblogoInputParams:
		return soap_in_PointerTons1__weblogoInputParams(soap, NULL, NULL, "ns1:weblogoInputParams");
	case SOAP_TYPE_PointerTons1__tRNAscanInputParams:
		return soap_in_PointerTons1__tRNAscanInputParams(soap, NULL, NULL, "ns1:tRNAscanInputParams");
	case SOAP_TYPE_PointerTons1__tcoffeeInputParams:
		return soap_in_PointerTons1__tcoffeeInputParams(soap, NULL, NULL, "ns1:tcoffeeInputParams");
	case SOAP_TYPE_PointerTons1__ssearchInputParams:
		return soap_in_PointerTons1__ssearchInputParams(soap, NULL, NULL, "ns1:ssearchInputParams");
	case SOAP_TYPE_PointerTons1__psortbInputParams:
		return soap_in_PointerTons1__psortbInputParams(soap, NULL, NULL, "ns1:psortbInputParams");
	case SOAP_TYPE_PointerTons1__psortInputParams:
		return soap_in_PointerTons1__psortInputParams(soap, NULL, NULL, "ns1:psortInputParams");
	case SOAP_TYPE_PointerTons1__phobiusInputParams:
		return soap_in_PointerTons1__phobiusInputParams(soap, NULL, NULL, "ns1:phobiusInputParams");
	case SOAP_TYPE_PointerTons1__muscleInputParams:
		return soap_in_PointerTons1__muscleInputParams(soap, NULL, NULL, "ns1:muscleInputParams");
	case SOAP_TYPE_PointerTons1__mafftInputParams:
		return soap_in_PointerTons1__mafftInputParams(soap, NULL, NULL, "ns1:mafftInputParams");
	case SOAP_TYPE_PointerTons1__kalignInputParams:
		return soap_in_PointerTons1__kalignInputParams(soap, NULL, NULL, "ns1:kalignInputParams");
	case SOAP_TYPE_PointerTons1__glimmerInputParams:
		return soap_in_PointerTons1__glimmerInputParams(soap, NULL, NULL, "ns1:glimmerInputParams");
	case SOAP_TYPE_PointerTons1__genemarkhmmInputParams:
		return soap_in_PointerTons1__genemarkhmmInputParams(soap, NULL, NULL, "ns1:genemarkhmmInputParams");
	case SOAP_TYPE_PointerTons1__fetchBatchInputParams:
		return soap_in_PointerTons1__fetchBatchInputParams(soap, NULL, NULL, "ns1:fetchBatchInputParams");
	case SOAP_TYPE_PointerTons1__fetchDataInputParams:
		return soap_in_PointerTons1__fetchDataInputParams(soap, NULL, NULL, "ns1:fetchDataInputParams");
	case SOAP_TYPE_PointerTons1__clustalwInputParams:
		return soap_in_PointerTons1__clustalwInputParams(soap, NULL, NULL, "ns1:clustalwInputParams");
	case SOAP_TYPE_PointerTons1__centroidfoldInputParams:
		return soap_in_PointerTons1__centroidfoldInputParams(soap, NULL, NULL, "ns1:centroidfoldInputParams");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons1__blastInputParams:
		return soap_in_PointerTons1__blastInputParams(soap, NULL, NULL, "ns1:blastInputParams");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMultiResult"))
		{	*type = SOAP_TYPE_ns1__getMultiResult;
			return soap_in_ns1__getMultiResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMultiResultResponse"))
		{	*type = SOAP_TYPE_ns1__getMultiResultResponse;
			return soap_in_ns1__getMultiResultResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getResult"))
		{	*type = SOAP_TYPE_ns1__getResult;
			return soap_in_ns1__getResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getResultResponse"))
		{	*type = SOAP_TYPE_ns1__getResultResponse;
			return soap_in_ns1__getResultResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkStatus_retJobid"))
		{	*type = SOAP_TYPE_ns1__checkStatus_USCOREretJobid;
			return soap_in_ns1__checkStatus_USCOREretJobid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkStatus_retJobidResponse"))
		{	*type = SOAP_TYPE_ns1__checkStatus_USCOREretJobidResponse;
			return soap_in_ns1__checkStatus_USCOREretJobidResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkStatus"))
		{	*type = SOAP_TYPE_ns1__checkStatus;
			return soap_in_ns1__checkStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkStatusResponse"))
		{	*type = SOAP_TYPE_ns1__checkStatusResponse;
			return soap_in_ns1__checkStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:map2PathwayProjector"))
		{	*type = SOAP_TYPE_ns1__map2PathwayProjector;
			return soap_in_ns1__map2PathwayProjector(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:map2PathwayProjectorResponse"))
		{	*type = SOAP_TYPE_ns1__map2PathwayProjectorResponse;
			return soap_in_ns1__map2PathwayProjectorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:showBlastDB"))
		{	*type = SOAP_TYPE_ns1__showBlastDB;
			return soap_in_ns1__showBlastDB(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:showBlastDBResponse"))
		{	*type = SOAP_TYPE_ns1__showBlastDBResponse;
			return soap_in_ns1__showBlastDBResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runRNAfold"))
		{	*type = SOAP_TYPE_ns1__runRNAfold;
			return soap_in_ns1__runRNAfold(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runRNAfoldResponse"))
		{	*type = SOAP_TYPE_ns1__runRNAfoldResponse;
			return soap_in_ns1__runRNAfoldResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runWolfPsort"))
		{	*type = SOAP_TYPE_ns1__runWolfPsort;
			return soap_in_ns1__runWolfPsort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runWolfPsortResponse"))
		{	*type = SOAP_TYPE_ns1__runWolfPsortResponse;
			return soap_in_ns1__runWolfPsortResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runWeblogo"))
		{	*type = SOAP_TYPE_ns1__runWeblogo;
			return soap_in_ns1__runWeblogo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runWeblogoResponse"))
		{	*type = SOAP_TYPE_ns1__runWeblogoResponse;
			return soap_in_ns1__runWeblogoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runtRNAscan"))
		{	*type = SOAP_TYPE_ns1__runtRNAscan;
			return soap_in_ns1__runtRNAscan(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runtRNAscanResponse"))
		{	*type = SOAP_TYPE_ns1__runtRNAscanResponse;
			return soap_in_ns1__runtRNAscanResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runTcoffee"))
		{	*type = SOAP_TYPE_ns1__runTcoffee;
			return soap_in_ns1__runTcoffee(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runTcoffeeResponse"))
		{	*type = SOAP_TYPE_ns1__runTcoffeeResponse;
			return soap_in_ns1__runTcoffeeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runSsearch"))
		{	*type = SOAP_TYPE_ns1__runSsearch;
			return soap_in_ns1__runSsearch(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runSsearchResponse"))
		{	*type = SOAP_TYPE_ns1__runSsearchResponse;
			return soap_in_ns1__runSsearchResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runPsortb"))
		{	*type = SOAP_TYPE_ns1__runPsortb;
			return soap_in_ns1__runPsortb(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runPsortbResponse"))
		{	*type = SOAP_TYPE_ns1__runPsortbResponse;
			return soap_in_ns1__runPsortbResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runPsort2"))
		{	*type = SOAP_TYPE_ns1__runPsort2;
			return soap_in_ns1__runPsort2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runPsort2Response"))
		{	*type = SOAP_TYPE_ns1__runPsort2Response;
			return soap_in_ns1__runPsort2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runPsort"))
		{	*type = SOAP_TYPE_ns1__runPsort;
			return soap_in_ns1__runPsort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runPsortResponse"))
		{	*type = SOAP_TYPE_ns1__runPsortResponse;
			return soap_in_ns1__runPsortResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runDolpenny"))
		{	*type = SOAP_TYPE_ns1__runDolpenny;
			return soap_in_ns1__runDolpenny(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runDolpennyResponse"))
		{	*type = SOAP_TYPE_ns1__runDolpennyResponse;
			return soap_in_ns1__runDolpennyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runDollop"))
		{	*type = SOAP_TYPE_ns1__runDollop;
			return soap_in_ns1__runDollop(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runDollopResponse"))
		{	*type = SOAP_TYPE_ns1__runDollopResponse;
			return soap_in_ns1__runDollopResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runPenny"))
		{	*type = SOAP_TYPE_ns1__runPenny;
			return soap_in_ns1__runPenny(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runPennyResponse"))
		{	*type = SOAP_TYPE_ns1__runPennyResponse;
			return soap_in_ns1__runPennyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runMix"))
		{	*type = SOAP_TYPE_ns1__runMix;
			return soap_in_ns1__runMix(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runMixResponse"))
		{	*type = SOAP_TYPE_ns1__runMixResponse;
			return soap_in_ns1__runMixResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runContml"))
		{	*type = SOAP_TYPE_ns1__runContml;
			return soap_in_ns1__runContml(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runContmlResponse"))
		{	*type = SOAP_TYPE_ns1__runContmlResponse;
			return soap_in_ns1__runContmlResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runNeighbor"))
		{	*type = SOAP_TYPE_ns1__runNeighbor;
			return soap_in_ns1__runNeighbor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runNeighborResponse"))
		{	*type = SOAP_TYPE_ns1__runNeighborResponse;
			return soap_in_ns1__runNeighborResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runKitsch"))
		{	*type = SOAP_TYPE_ns1__runKitsch;
			return soap_in_ns1__runKitsch(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runKitschResponse"))
		{	*type = SOAP_TYPE_ns1__runKitschResponse;
			return soap_in_ns1__runKitschResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runFitch"))
		{	*type = SOAP_TYPE_ns1__runFitch;
			return soap_in_ns1__runFitch(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runFitchResponse"))
		{	*type = SOAP_TYPE_ns1__runFitchResponse;
			return soap_in_ns1__runFitchResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runClique"))
		{	*type = SOAP_TYPE_ns1__runClique;
			return soap_in_ns1__runClique(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runCliqueResponse"))
		{	*type = SOAP_TYPE_ns1__runCliqueResponse;
			return soap_in_ns1__runCliqueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runRestml"))
		{	*type = SOAP_TYPE_ns1__runRestml;
			return soap_in_ns1__runRestml(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runRestmlResponse"))
		{	*type = SOAP_TYPE_ns1__runRestmlResponse;
			return soap_in_ns1__runRestmlResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runSeqboot"))
		{	*type = SOAP_TYPE_ns1__runSeqboot;
			return soap_in_ns1__runSeqboot(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runSeqbootResponse"))
		{	*type = SOAP_TYPE_ns1__runSeqbootResponse;
			return soap_in_ns1__runSeqbootResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runGendist"))
		{	*type = SOAP_TYPE_ns1__runGendist;
			return soap_in_ns1__runGendist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runGendistResponse"))
		{	*type = SOAP_TYPE_ns1__runGendistResponse;
			return soap_in_ns1__runGendistResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runDnadist"))
		{	*type = SOAP_TYPE_ns1__runDnadist;
			return soap_in_ns1__runDnadist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runDnadistResponse"))
		{	*type = SOAP_TYPE_ns1__runDnadistResponse;
			return soap_in_ns1__runDnadistResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runDnamlk"))
		{	*type = SOAP_TYPE_ns1__runDnamlk;
			return soap_in_ns1__runDnamlk(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runDnamlkResponse"))
		{	*type = SOAP_TYPE_ns1__runDnamlkResponse;
			return soap_in_ns1__runDnamlkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runDnaml"))
		{	*type = SOAP_TYPE_ns1__runDnaml;
			return soap_in_ns1__runDnaml(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runDnamlResponse"))
		{	*type = SOAP_TYPE_ns1__runDnamlResponse;
			return soap_in_ns1__runDnamlResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runDnainvar"))
		{	*type = SOAP_TYPE_ns1__runDnainvar;
			return soap_in_ns1__runDnainvar(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runDnainvarResponse"))
		{	*type = SOAP_TYPE_ns1__runDnainvarResponse;
			return soap_in_ns1__runDnainvarResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runDnacomp"))
		{	*type = SOAP_TYPE_ns1__runDnacomp;
			return soap_in_ns1__runDnacomp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runDnacompResponse"))
		{	*type = SOAP_TYPE_ns1__runDnacompResponse;
			return soap_in_ns1__runDnacompResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runDnapenny"))
		{	*type = SOAP_TYPE_ns1__runDnapenny;
			return soap_in_ns1__runDnapenny(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runDnapennyResponse"))
		{	*type = SOAP_TYPE_ns1__runDnapennyResponse;
			return soap_in_ns1__runDnapennyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runDnapars"))
		{	*type = SOAP_TYPE_ns1__runDnapars;
			return soap_in_ns1__runDnapars(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runDnaparsResponse"))
		{	*type = SOAP_TYPE_ns1__runDnaparsResponse;
			return soap_in_ns1__runDnaparsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runProtdist"))
		{	*type = SOAP_TYPE_ns1__runProtdist;
			return soap_in_ns1__runProtdist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runProtdistResponse"))
		{	*type = SOAP_TYPE_ns1__runProtdistResponse;
			return soap_in_ns1__runProtdistResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runProtpars"))
		{	*type = SOAP_TYPE_ns1__runProtpars;
			return soap_in_ns1__runProtpars(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runProtparsResponse"))
		{	*type = SOAP_TYPE_ns1__runProtparsResponse;
			return soap_in_ns1__runProtparsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runPhobius"))
		{	*type = SOAP_TYPE_ns1__runPhobius;
			return soap_in_ns1__runPhobius(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runPhobiusResponse"))
		{	*type = SOAP_TYPE_ns1__runPhobiusResponse;
			return soap_in_ns1__runPhobiusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runMuscle"))
		{	*type = SOAP_TYPE_ns1__runMuscle;
			return soap_in_ns1__runMuscle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runMuscleResponse"))
		{	*type = SOAP_TYPE_ns1__runMuscleResponse;
			return soap_in_ns1__runMuscleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runMafft"))
		{	*type = SOAP_TYPE_ns1__runMafft;
			return soap_in_ns1__runMafft(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runMafftResponse"))
		{	*type = SOAP_TYPE_ns1__runMafftResponse;
			return soap_in_ns1__runMafftResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runKalign"))
		{	*type = SOAP_TYPE_ns1__runKalign;
			return soap_in_ns1__runKalign(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runKalignResponse"))
		{	*type = SOAP_TYPE_ns1__runKalignResponse;
			return soap_in_ns1__runKalignResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runGlimmer"))
		{	*type = SOAP_TYPE_ns1__runGlimmer;
			return soap_in_ns1__runGlimmer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runGlimmerResponse"))
		{	*type = SOAP_TYPE_ns1__runGlimmerResponse;
			return soap_in_ns1__runGlimmerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runGenemarkhmm"))
		{	*type = SOAP_TYPE_ns1__runGenemarkhmm;
			return soap_in_ns1__runGenemarkhmm(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runGenemarkhmmResponse"))
		{	*type = SOAP_TYPE_ns1__runGenemarkhmmResponse;
			return soap_in_ns1__runGenemarkhmmResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runFetchBatch"))
		{	*type = SOAP_TYPE_ns1__runFetchBatch;
			return soap_in_ns1__runFetchBatch(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runFetchBatchResponse"))
		{	*type = SOAP_TYPE_ns1__runFetchBatchResponse;
			return soap_in_ns1__runFetchBatchResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runFetchData"))
		{	*type = SOAP_TYPE_ns1__runFetchData;
			return soap_in_ns1__runFetchData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runFetchDataResponse"))
		{	*type = SOAP_TYPE_ns1__runFetchDataResponse;
			return soap_in_ns1__runFetchDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runClustalw"))
		{	*type = SOAP_TYPE_ns1__runClustalw;
			return soap_in_ns1__runClustalw(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runClustalwResponse"))
		{	*type = SOAP_TYPE_ns1__runClustalwResponse;
			return soap_in_ns1__runClustalwResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runCentroidfold"))
		{	*type = SOAP_TYPE_ns1__runCentroidfold;
			return soap_in_ns1__runCentroidfold(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runCentroidfoldResponse"))
		{	*type = SOAP_TYPE_ns1__runCentroidfoldResponse;
			return soap_in_ns1__runCentroidfoldResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runBlast"))
		{	*type = SOAP_TYPE_ns1__runBlast;
			return soap_in_ns1__runBlast(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:runBlastResponse"))
		{	*type = SOAP_TYPE_ns1__runBlastResponse;
			return soap_in_ns1__runBlastResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:showBlastDBInputParams"))
		{	*type = SOAP_TYPE_ns1__showBlastDBInputParams;
			return soap_in_ns1__showBlastDBInputParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RNAfoldInputParams"))
		{	*type = SOAP_TYPE_ns1__RNAfoldInputParams;
			return soap_in_ns1__RNAfoldInputParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wolfPsortInputParams"))
		{	*type = SOAP_TYPE_ns1__wolfPsortInputParams;
			return soap_in_ns1__wolfPsortInputParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:weblogoInputParams"))
		{	*type = SOAP_TYPE_ns1__weblogoInputParams;
			return soap_in_ns1__weblogoInputParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ssearchInputParams"))
		{	*type = SOAP_TYPE_ns1__ssearchInputParams;
			return soap_in_ns1__ssearchInputParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:tRNAscanInputParams"))
		{	*type = SOAP_TYPE_ns1__tRNAscanInputParams;
			return soap_in_ns1__tRNAscanInputParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:tcoffeeInputParams"))
		{	*type = SOAP_TYPE_ns1__tcoffeeInputParams;
			return soap_in_ns1__tcoffeeInputParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:psortbInputParams"))
		{	*type = SOAP_TYPE_ns1__psortbInputParams;
			return soap_in_ns1__psortbInputParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:psortInputParams"))
		{	*type = SOAP_TYPE_ns1__psortInputParams;
			return soap_in_ns1__psortInputParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:phobiusInputParams"))
		{	*type = SOAP_TYPE_ns1__phobiusInputParams;
			return soap_in_ns1__phobiusInputParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:muscleInputParams"))
		{	*type = SOAP_TYPE_ns1__muscleInputParams;
			return soap_in_ns1__muscleInputParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mafftInputParams"))
		{	*type = SOAP_TYPE_ns1__mafftInputParams;
			return soap_in_ns1__mafftInputParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:kalignInputParams"))
		{	*type = SOAP_TYPE_ns1__kalignInputParams;
			return soap_in_ns1__kalignInputParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:glimmerInputParams"))
		{	*type = SOAP_TYPE_ns1__glimmerInputParams;
			return soap_in_ns1__glimmerInputParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:genemarkhmmInputParams"))
		{	*type = SOAP_TYPE_ns1__genemarkhmmInputParams;
			return soap_in_ns1__genemarkhmmInputParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fetchBatchInputParams"))
		{	*type = SOAP_TYPE_ns1__fetchBatchInputParams;
			return soap_in_ns1__fetchBatchInputParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fetchDataInputParams"))
		{	*type = SOAP_TYPE_ns1__fetchDataInputParams;
			return soap_in_ns1__fetchDataInputParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:clustalwInputParams"))
		{	*type = SOAP_TYPE_ns1__clustalwInputParams;
			return soap_in_ns1__clustalwInputParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:centroidfoldInputParams"))
		{	*type = SOAP_TYPE_ns1__centroidfoldInputParams;
			return soap_in_ns1__centroidfoldInputParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:blastInputParams"))
		{	*type = SOAP_TYPE_ns1__blastInputParams;
			return soap_in_ns1__blastInputParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const enum xsd__boolean *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__getMultiResult:
		return soap_out_ns1__getMultiResult(soap, tag, id, (const struct ns1__getMultiResult *)ptr, "ns1:getMultiResult");
	case SOAP_TYPE_ns1__getMultiResultResponse:
		return soap_out_ns1__getMultiResultResponse(soap, tag, id, (const struct ns1__getMultiResultResponse *)ptr, "ns1:getMultiResultResponse");
	case SOAP_TYPE_ns1__getResult:
		return soap_out_ns1__getResult(soap, tag, id, (const struct ns1__getResult *)ptr, "ns1:getResult");
	case SOAP_TYPE_ns1__getResultResponse:
		return soap_out_ns1__getResultResponse(soap, tag, id, (const struct ns1__getResultResponse *)ptr, "ns1:getResultResponse");
	case SOAP_TYPE_ns1__checkStatus_USCOREretJobid:
		return soap_out_ns1__checkStatus_USCOREretJobid(soap, tag, id, (const struct ns1__checkStatus_USCOREretJobid *)ptr, "ns1:checkStatus_retJobid");
	case SOAP_TYPE_ns1__checkStatus_USCOREretJobidResponse:
		return soap_out_ns1__checkStatus_USCOREretJobidResponse(soap, tag, id, (const struct ns1__checkStatus_USCOREretJobidResponse *)ptr, "ns1:checkStatus_retJobidResponse");
	case SOAP_TYPE_ns1__checkStatus:
		return soap_out_ns1__checkStatus(soap, tag, id, (const struct ns1__checkStatus *)ptr, "ns1:checkStatus");
	case SOAP_TYPE_ns1__checkStatusResponse:
		return soap_out_ns1__checkStatusResponse(soap, tag, id, (const struct ns1__checkStatusResponse *)ptr, "ns1:checkStatusResponse");
	case SOAP_TYPE_ns1__map2PathwayProjector:
		return soap_out_ns1__map2PathwayProjector(soap, tag, id, (const struct ns1__map2PathwayProjector *)ptr, "ns1:map2PathwayProjector");
	case SOAP_TYPE_ns1__map2PathwayProjectorResponse:
		return soap_out_ns1__map2PathwayProjectorResponse(soap, tag, id, (const struct ns1__map2PathwayProjectorResponse *)ptr, "ns1:map2PathwayProjectorResponse");
	case SOAP_TYPE_ns1__showBlastDB:
		return soap_out_ns1__showBlastDB(soap, tag, id, (const struct ns1__showBlastDB *)ptr, "ns1:showBlastDB");
	case SOAP_TYPE_ns1__showBlastDBResponse:
		return soap_out_ns1__showBlastDBResponse(soap, tag, id, (const struct ns1__showBlastDBResponse *)ptr, "ns1:showBlastDBResponse");
	case SOAP_TYPE_ns1__runRNAfold:
		return soap_out_ns1__runRNAfold(soap, tag, id, (const struct ns1__runRNAfold *)ptr, "ns1:runRNAfold");
	case SOAP_TYPE_ns1__runRNAfoldResponse:
		return soap_out_ns1__runRNAfoldResponse(soap, tag, id, (const struct ns1__runRNAfoldResponse *)ptr, "ns1:runRNAfoldResponse");
	case SOAP_TYPE_ns1__runWolfPsort:
		return soap_out_ns1__runWolfPsort(soap, tag, id, (const struct ns1__runWolfPsort *)ptr, "ns1:runWolfPsort");
	case SOAP_TYPE_ns1__runWolfPsortResponse:
		return soap_out_ns1__runWolfPsortResponse(soap, tag, id, (const struct ns1__runWolfPsortResponse *)ptr, "ns1:runWolfPsortResponse");
	case SOAP_TYPE_ns1__runWeblogo:
		return soap_out_ns1__runWeblogo(soap, tag, id, (const struct ns1__runWeblogo *)ptr, "ns1:runWeblogo");
	case SOAP_TYPE_ns1__runWeblogoResponse:
		return soap_out_ns1__runWeblogoResponse(soap, tag, id, (const struct ns1__runWeblogoResponse *)ptr, "ns1:runWeblogoResponse");
	case SOAP_TYPE_ns1__runtRNAscan:
		return soap_out_ns1__runtRNAscan(soap, tag, id, (const struct ns1__runtRNAscan *)ptr, "ns1:runtRNAscan");
	case SOAP_TYPE_ns1__runtRNAscanResponse:
		return soap_out_ns1__runtRNAscanResponse(soap, tag, id, (const struct ns1__runtRNAscanResponse *)ptr, "ns1:runtRNAscanResponse");
	case SOAP_TYPE_ns1__runTcoffee:
		return soap_out_ns1__runTcoffee(soap, tag, id, (const struct ns1__runTcoffee *)ptr, "ns1:runTcoffee");
	case SOAP_TYPE_ns1__runTcoffeeResponse:
		return soap_out_ns1__runTcoffeeResponse(soap, tag, id, (const struct ns1__runTcoffeeResponse *)ptr, "ns1:runTcoffeeResponse");
	case SOAP_TYPE_ns1__runSsearch:
		return soap_out_ns1__runSsearch(soap, tag, id, (const struct ns1__runSsearch *)ptr, "ns1:runSsearch");
	case SOAP_TYPE_ns1__runSsearchResponse:
		return soap_out_ns1__runSsearchResponse(soap, tag, id, (const struct ns1__runSsearchResponse *)ptr, "ns1:runSsearchResponse");
	case SOAP_TYPE_ns1__runPsortb:
		return soap_out_ns1__runPsortb(soap, tag, id, (const struct ns1__runPsortb *)ptr, "ns1:runPsortb");
	case SOAP_TYPE_ns1__runPsortbResponse:
		return soap_out_ns1__runPsortbResponse(soap, tag, id, (const struct ns1__runPsortbResponse *)ptr, "ns1:runPsortbResponse");
	case SOAP_TYPE_ns1__runPsort2:
		return soap_out_ns1__runPsort2(soap, tag, id, (const struct ns1__runPsort2 *)ptr, "ns1:runPsort2");
	case SOAP_TYPE_ns1__runPsort2Response:
		return soap_out_ns1__runPsort2Response(soap, tag, id, (const struct ns1__runPsort2Response *)ptr, "ns1:runPsort2Response");
	case SOAP_TYPE_ns1__runPsort:
		return soap_out_ns1__runPsort(soap, tag, id, (const struct ns1__runPsort *)ptr, "ns1:runPsort");
	case SOAP_TYPE_ns1__runPsortResponse:
		return soap_out_ns1__runPsortResponse(soap, tag, id, (const struct ns1__runPsortResponse *)ptr, "ns1:runPsortResponse");
	case SOAP_TYPE_ns1__runDolpenny:
		return soap_out_ns1__runDolpenny(soap, tag, id, (const struct ns1__runDolpenny *)ptr, "ns1:runDolpenny");
	case SOAP_TYPE_ns1__runDolpennyResponse:
		return soap_out_ns1__runDolpennyResponse(soap, tag, id, (const struct ns1__runDolpennyResponse *)ptr, "ns1:runDolpennyResponse");
	case SOAP_TYPE_ns1__runDollop:
		return soap_out_ns1__runDollop(soap, tag, id, (const struct ns1__runDollop *)ptr, "ns1:runDollop");
	case SOAP_TYPE_ns1__runDollopResponse:
		return soap_out_ns1__runDollopResponse(soap, tag, id, (const struct ns1__runDollopResponse *)ptr, "ns1:runDollopResponse");
	case SOAP_TYPE_ns1__runPenny:
		return soap_out_ns1__runPenny(soap, tag, id, (const struct ns1__runPenny *)ptr, "ns1:runPenny");
	case SOAP_TYPE_ns1__runPennyResponse:
		return soap_out_ns1__runPennyResponse(soap, tag, id, (const struct ns1__runPennyResponse *)ptr, "ns1:runPennyResponse");
	case SOAP_TYPE_ns1__runMix:
		return soap_out_ns1__runMix(soap, tag, id, (const struct ns1__runMix *)ptr, "ns1:runMix");
	case SOAP_TYPE_ns1__runMixResponse:
		return soap_out_ns1__runMixResponse(soap, tag, id, (const struct ns1__runMixResponse *)ptr, "ns1:runMixResponse");
	case SOAP_TYPE_ns1__runContml:
		return soap_out_ns1__runContml(soap, tag, id, (const struct ns1__runContml *)ptr, "ns1:runContml");
	case SOAP_TYPE_ns1__runContmlResponse:
		return soap_out_ns1__runContmlResponse(soap, tag, id, (const struct ns1__runContmlResponse *)ptr, "ns1:runContmlResponse");
	case SOAP_TYPE_ns1__runNeighbor:
		return soap_out_ns1__runNeighbor(soap, tag, id, (const struct ns1__runNeighbor *)ptr, "ns1:runNeighbor");
	case SOAP_TYPE_ns1__runNeighborResponse:
		return soap_out_ns1__runNeighborResponse(soap, tag, id, (const struct ns1__runNeighborResponse *)ptr, "ns1:runNeighborResponse");
	case SOAP_TYPE_ns1__runKitsch:
		return soap_out_ns1__runKitsch(soap, tag, id, (const struct ns1__runKitsch *)ptr, "ns1:runKitsch");
	case SOAP_TYPE_ns1__runKitschResponse:
		return soap_out_ns1__runKitschResponse(soap, tag, id, (const struct ns1__runKitschResponse *)ptr, "ns1:runKitschResponse");
	case SOAP_TYPE_ns1__runFitch:
		return soap_out_ns1__runFitch(soap, tag, id, (const struct ns1__runFitch *)ptr, "ns1:runFitch");
	case SOAP_TYPE_ns1__runFitchResponse:
		return soap_out_ns1__runFitchResponse(soap, tag, id, (const struct ns1__runFitchResponse *)ptr, "ns1:runFitchResponse");
	case SOAP_TYPE_ns1__runClique:
		return soap_out_ns1__runClique(soap, tag, id, (const struct ns1__runClique *)ptr, "ns1:runClique");
	case SOAP_TYPE_ns1__runCliqueResponse:
		return soap_out_ns1__runCliqueResponse(soap, tag, id, (const struct ns1__runCliqueResponse *)ptr, "ns1:runCliqueResponse");
	case SOAP_TYPE_ns1__runRestml:
		return soap_out_ns1__runRestml(soap, tag, id, (const struct ns1__runRestml *)ptr, "ns1:runRestml");
	case SOAP_TYPE_ns1__runRestmlResponse:
		return soap_out_ns1__runRestmlResponse(soap, tag, id, (const struct ns1__runRestmlResponse *)ptr, "ns1:runRestmlResponse");
	case SOAP_TYPE_ns1__runSeqboot:
		return soap_out_ns1__runSeqboot(soap, tag, id, (const struct ns1__runSeqboot *)ptr, "ns1:runSeqboot");
	case SOAP_TYPE_ns1__runSeqbootResponse:
		return soap_out_ns1__runSeqbootResponse(soap, tag, id, (const struct ns1__runSeqbootResponse *)ptr, "ns1:runSeqbootResponse");
	case SOAP_TYPE_ns1__runGendist:
		return soap_out_ns1__runGendist(soap, tag, id, (const struct ns1__runGendist *)ptr, "ns1:runGendist");
	case SOAP_TYPE_ns1__runGendistResponse:
		return soap_out_ns1__runGendistResponse(soap, tag, id, (const struct ns1__runGendistResponse *)ptr, "ns1:runGendistResponse");
	case SOAP_TYPE_ns1__runDnadist:
		return soap_out_ns1__runDnadist(soap, tag, id, (const struct ns1__runDnadist *)ptr, "ns1:runDnadist");
	case SOAP_TYPE_ns1__runDnadistResponse:
		return soap_out_ns1__runDnadistResponse(soap, tag, id, (const struct ns1__runDnadistResponse *)ptr, "ns1:runDnadistResponse");
	case SOAP_TYPE_ns1__runDnamlk:
		return soap_out_ns1__runDnamlk(soap, tag, id, (const struct ns1__runDnamlk *)ptr, "ns1:runDnamlk");
	case SOAP_TYPE_ns1__runDnamlkResponse:
		return soap_out_ns1__runDnamlkResponse(soap, tag, id, (const struct ns1__runDnamlkResponse *)ptr, "ns1:runDnamlkResponse");
	case SOAP_TYPE_ns1__runDnaml:
		return soap_out_ns1__runDnaml(soap, tag, id, (const struct ns1__runDnaml *)ptr, "ns1:runDnaml");
	case SOAP_TYPE_ns1__runDnamlResponse:
		return soap_out_ns1__runDnamlResponse(soap, tag, id, (const struct ns1__runDnamlResponse *)ptr, "ns1:runDnamlResponse");
	case SOAP_TYPE_ns1__runDnainvar:
		return soap_out_ns1__runDnainvar(soap, tag, id, (const struct ns1__runDnainvar *)ptr, "ns1:runDnainvar");
	case SOAP_TYPE_ns1__runDnainvarResponse:
		return soap_out_ns1__runDnainvarResponse(soap, tag, id, (const struct ns1__runDnainvarResponse *)ptr, "ns1:runDnainvarResponse");
	case SOAP_TYPE_ns1__runDnacomp:
		return soap_out_ns1__runDnacomp(soap, tag, id, (const struct ns1__runDnacomp *)ptr, "ns1:runDnacomp");
	case SOAP_TYPE_ns1__runDnacompResponse:
		return soap_out_ns1__runDnacompResponse(soap, tag, id, (const struct ns1__runDnacompResponse *)ptr, "ns1:runDnacompResponse");
	case SOAP_TYPE_ns1__runDnapenny:
		return soap_out_ns1__runDnapenny(soap, tag, id, (const struct ns1__runDnapenny *)ptr, "ns1:runDnapenny");
	case SOAP_TYPE_ns1__runDnapennyResponse:
		return soap_out_ns1__runDnapennyResponse(soap, tag, id, (const struct ns1__runDnapennyResponse *)ptr, "ns1:runDnapennyResponse");
	case SOAP_TYPE_ns1__runDnapars:
		return soap_out_ns1__runDnapars(soap, tag, id, (const struct ns1__runDnapars *)ptr, "ns1:runDnapars");
	case SOAP_TYPE_ns1__runDnaparsResponse:
		return soap_out_ns1__runDnaparsResponse(soap, tag, id, (const struct ns1__runDnaparsResponse *)ptr, "ns1:runDnaparsResponse");
	case SOAP_TYPE_ns1__runProtdist:
		return soap_out_ns1__runProtdist(soap, tag, id, (const struct ns1__runProtdist *)ptr, "ns1:runProtdist");
	case SOAP_TYPE_ns1__runProtdistResponse:
		return soap_out_ns1__runProtdistResponse(soap, tag, id, (const struct ns1__runProtdistResponse *)ptr, "ns1:runProtdistResponse");
	case SOAP_TYPE_ns1__runProtpars:
		return soap_out_ns1__runProtpars(soap, tag, id, (const struct ns1__runProtpars *)ptr, "ns1:runProtpars");
	case SOAP_TYPE_ns1__runProtparsResponse:
		return soap_out_ns1__runProtparsResponse(soap, tag, id, (const struct ns1__runProtparsResponse *)ptr, "ns1:runProtparsResponse");
	case SOAP_TYPE_ns1__runPhobius:
		return soap_out_ns1__runPhobius(soap, tag, id, (const struct ns1__runPhobius *)ptr, "ns1:runPhobius");
	case SOAP_TYPE_ns1__runPhobiusResponse:
		return soap_out_ns1__runPhobiusResponse(soap, tag, id, (const struct ns1__runPhobiusResponse *)ptr, "ns1:runPhobiusResponse");
	case SOAP_TYPE_ns1__runMuscle:
		return soap_out_ns1__runMuscle(soap, tag, id, (const struct ns1__runMuscle *)ptr, "ns1:runMuscle");
	case SOAP_TYPE_ns1__runMuscleResponse:
		return soap_out_ns1__runMuscleResponse(soap, tag, id, (const struct ns1__runMuscleResponse *)ptr, "ns1:runMuscleResponse");
	case SOAP_TYPE_ns1__runMafft:
		return soap_out_ns1__runMafft(soap, tag, id, (const struct ns1__runMafft *)ptr, "ns1:runMafft");
	case SOAP_TYPE_ns1__runMafftResponse:
		return soap_out_ns1__runMafftResponse(soap, tag, id, (const struct ns1__runMafftResponse *)ptr, "ns1:runMafftResponse");
	case SOAP_TYPE_ns1__runKalign:
		return soap_out_ns1__runKalign(soap, tag, id, (const struct ns1__runKalign *)ptr, "ns1:runKalign");
	case SOAP_TYPE_ns1__runKalignResponse:
		return soap_out_ns1__runKalignResponse(soap, tag, id, (const struct ns1__runKalignResponse *)ptr, "ns1:runKalignResponse");
	case SOAP_TYPE_ns1__runGlimmer:
		return soap_out_ns1__runGlimmer(soap, tag, id, (const struct ns1__runGlimmer *)ptr, "ns1:runGlimmer");
	case SOAP_TYPE_ns1__runGlimmerResponse:
		return soap_out_ns1__runGlimmerResponse(soap, tag, id, (const struct ns1__runGlimmerResponse *)ptr, "ns1:runGlimmerResponse");
	case SOAP_TYPE_ns1__runGenemarkhmm:
		return soap_out_ns1__runGenemarkhmm(soap, tag, id, (const struct ns1__runGenemarkhmm *)ptr, "ns1:runGenemarkhmm");
	case SOAP_TYPE_ns1__runGenemarkhmmResponse:
		return soap_out_ns1__runGenemarkhmmResponse(soap, tag, id, (const struct ns1__runGenemarkhmmResponse *)ptr, "ns1:runGenemarkhmmResponse");
	case SOAP_TYPE_ns1__runFetchBatch:
		return soap_out_ns1__runFetchBatch(soap, tag, id, (const struct ns1__runFetchBatch *)ptr, "ns1:runFetchBatch");
	case SOAP_TYPE_ns1__runFetchBatchResponse:
		return soap_out_ns1__runFetchBatchResponse(soap, tag, id, (const struct ns1__runFetchBatchResponse *)ptr, "ns1:runFetchBatchResponse");
	case SOAP_TYPE_ns1__runFetchData:
		return soap_out_ns1__runFetchData(soap, tag, id, (const struct ns1__runFetchData *)ptr, "ns1:runFetchData");
	case SOAP_TYPE_ns1__runFetchDataResponse:
		return soap_out_ns1__runFetchDataResponse(soap, tag, id, (const struct ns1__runFetchDataResponse *)ptr, "ns1:runFetchDataResponse");
	case SOAP_TYPE_ns1__runClustalw:
		return soap_out_ns1__runClustalw(soap, tag, id, (const struct ns1__runClustalw *)ptr, "ns1:runClustalw");
	case SOAP_TYPE_ns1__runClustalwResponse:
		return soap_out_ns1__runClustalwResponse(soap, tag, id, (const struct ns1__runClustalwResponse *)ptr, "ns1:runClustalwResponse");
	case SOAP_TYPE_ns1__runCentroidfold:
		return soap_out_ns1__runCentroidfold(soap, tag, id, (const struct ns1__runCentroidfold *)ptr, "ns1:runCentroidfold");
	case SOAP_TYPE_ns1__runCentroidfoldResponse:
		return soap_out_ns1__runCentroidfoldResponse(soap, tag, id, (const struct ns1__runCentroidfoldResponse *)ptr, "ns1:runCentroidfoldResponse");
	case SOAP_TYPE_ns1__runBlast:
		return soap_out_ns1__runBlast(soap, tag, id, (const struct ns1__runBlast *)ptr, "ns1:runBlast");
	case SOAP_TYPE_ns1__runBlastResponse:
		return soap_out_ns1__runBlastResponse(soap, tag, id, (const struct ns1__runBlastResponse *)ptr, "ns1:runBlastResponse");
	case SOAP_TYPE_ns1__showBlastDBInputParams:
		return soap_out_ns1__showBlastDBInputParams(soap, tag, id, (const struct ns1__showBlastDBInputParams *)ptr, "ns1:showBlastDBInputParams");
	case SOAP_TYPE_ns1__RNAfoldInputParams:
		return soap_out_ns1__RNAfoldInputParams(soap, tag, id, (const struct ns1__RNAfoldInputParams *)ptr, "ns1:RNAfoldInputParams");
	case SOAP_TYPE_ns1__wolfPsortInputParams:
		return soap_out_ns1__wolfPsortInputParams(soap, tag, id, (const struct ns1__wolfPsortInputParams *)ptr, "ns1:wolfPsortInputParams");
	case SOAP_TYPE_ns1__weblogoInputParams:
		return soap_out_ns1__weblogoInputParams(soap, tag, id, (const struct ns1__weblogoInputParams *)ptr, "ns1:weblogoInputParams");
	case SOAP_TYPE_ns1__ssearchInputParams:
		return soap_out_ns1__ssearchInputParams(soap, tag, id, (const struct ns1__ssearchInputParams *)ptr, "ns1:ssearchInputParams");
	case SOAP_TYPE_ns1__tRNAscanInputParams:
		return soap_out_ns1__tRNAscanInputParams(soap, tag, id, (const struct ns1__tRNAscanInputParams *)ptr, "ns1:tRNAscanInputParams");
	case SOAP_TYPE_ns1__tcoffeeInputParams:
		return soap_out_ns1__tcoffeeInputParams(soap, tag, id, (const struct ns1__tcoffeeInputParams *)ptr, "ns1:tcoffeeInputParams");
	case SOAP_TYPE_ns1__psortbInputParams:
		return soap_out_ns1__psortbInputParams(soap, tag, id, (const struct ns1__psortbInputParams *)ptr, "ns1:psortbInputParams");
	case SOAP_TYPE_ns1__psortInputParams:
		return soap_out_ns1__psortInputParams(soap, tag, id, (const struct ns1__psortInputParams *)ptr, "ns1:psortInputParams");
	case SOAP_TYPE_ns1__phobiusInputParams:
		return soap_out_ns1__phobiusInputParams(soap, tag, id, (const struct ns1__phobiusInputParams *)ptr, "ns1:phobiusInputParams");
	case SOAP_TYPE_ns1__muscleInputParams:
		return soap_out_ns1__muscleInputParams(soap, tag, id, (const struct ns1__muscleInputParams *)ptr, "ns1:muscleInputParams");
	case SOAP_TYPE_ns1__mafftInputParams:
		return soap_out_ns1__mafftInputParams(soap, tag, id, (const struct ns1__mafftInputParams *)ptr, "ns1:mafftInputParams");
	case SOAP_TYPE_ns1__kalignInputParams:
		return soap_out_ns1__kalignInputParams(soap, tag, id, (const struct ns1__kalignInputParams *)ptr, "ns1:kalignInputParams");
	case SOAP_TYPE_ns1__glimmerInputParams:
		return soap_out_ns1__glimmerInputParams(soap, tag, id, (const struct ns1__glimmerInputParams *)ptr, "ns1:glimmerInputParams");
	case SOAP_TYPE_ns1__genemarkhmmInputParams:
		return soap_out_ns1__genemarkhmmInputParams(soap, tag, id, (const struct ns1__genemarkhmmInputParams *)ptr, "ns1:genemarkhmmInputParams");
	case SOAP_TYPE_ns1__fetchBatchInputParams:
		return soap_out_ns1__fetchBatchInputParams(soap, tag, id, (const struct ns1__fetchBatchInputParams *)ptr, "ns1:fetchBatchInputParams");
	case SOAP_TYPE_ns1__fetchDataInputParams:
		return soap_out_ns1__fetchDataInputParams(soap, tag, id, (const struct ns1__fetchDataInputParams *)ptr, "ns1:fetchDataInputParams");
	case SOAP_TYPE_ns1__clustalwInputParams:
		return soap_out_ns1__clustalwInputParams(soap, tag, id, (const struct ns1__clustalwInputParams *)ptr, "ns1:clustalwInputParams");
	case SOAP_TYPE_ns1__centroidfoldInputParams:
		return soap_out_ns1__centroidfoldInputParams(soap, tag, id, (const struct ns1__centroidfoldInputParams *)ptr, "ns1:centroidfoldInputParams");
	case SOAP_TYPE_ns1__blastInputParams:
		return soap_out_ns1__blastInputParams(soap, tag, id, (const struct ns1__blastInputParams *)ptr, "ns1:blastInputParams");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTons1__showBlastDBInputParams:
		return soap_out_PointerTons1__showBlastDBInputParams(soap, tag, id, (struct ns1__showBlastDBInputParams *const*)ptr, "ns1:showBlastDBInputParams");
	case SOAP_TYPE_PointerTons1__RNAfoldInputParams:
		return soap_out_PointerTons1__RNAfoldInputParams(soap, tag, id, (struct ns1__RNAfoldInputParams *const*)ptr, "ns1:RNAfoldInputParams");
	case SOAP_TYPE_PointerTons1__wolfPsortInputParams:
		return soap_out_PointerTons1__wolfPsortInputParams(soap, tag, id, (struct ns1__wolfPsortInputParams *const*)ptr, "ns1:wolfPsortInputParams");
	case SOAP_TYPE_PointerTons1__weblogoInputParams:
		return soap_out_PointerTons1__weblogoInputParams(soap, tag, id, (struct ns1__weblogoInputParams *const*)ptr, "ns1:weblogoInputParams");
	case SOAP_TYPE_PointerTons1__tRNAscanInputParams:
		return soap_out_PointerTons1__tRNAscanInputParams(soap, tag, id, (struct ns1__tRNAscanInputParams *const*)ptr, "ns1:tRNAscanInputParams");
	case SOAP_TYPE_PointerTons1__tcoffeeInputParams:
		return soap_out_PointerTons1__tcoffeeInputParams(soap, tag, id, (struct ns1__tcoffeeInputParams *const*)ptr, "ns1:tcoffeeInputParams");
	case SOAP_TYPE_PointerTons1__ssearchInputParams:
		return soap_out_PointerTons1__ssearchInputParams(soap, tag, id, (struct ns1__ssearchInputParams *const*)ptr, "ns1:ssearchInputParams");
	case SOAP_TYPE_PointerTons1__psortbInputParams:
		return soap_out_PointerTons1__psortbInputParams(soap, tag, id, (struct ns1__psortbInputParams *const*)ptr, "ns1:psortbInputParams");
	case SOAP_TYPE_PointerTons1__psortInputParams:
		return soap_out_PointerTons1__psortInputParams(soap, tag, id, (struct ns1__psortInputParams *const*)ptr, "ns1:psortInputParams");
	case SOAP_TYPE_PointerTons1__phobiusInputParams:
		return soap_out_PointerTons1__phobiusInputParams(soap, tag, id, (struct ns1__phobiusInputParams *const*)ptr, "ns1:phobiusInputParams");
	case SOAP_TYPE_PointerTons1__muscleInputParams:
		return soap_out_PointerTons1__muscleInputParams(soap, tag, id, (struct ns1__muscleInputParams *const*)ptr, "ns1:muscleInputParams");
	case SOAP_TYPE_PointerTons1__mafftInputParams:
		return soap_out_PointerTons1__mafftInputParams(soap, tag, id, (struct ns1__mafftInputParams *const*)ptr, "ns1:mafftInputParams");
	case SOAP_TYPE_PointerTons1__kalignInputParams:
		return soap_out_PointerTons1__kalignInputParams(soap, tag, id, (struct ns1__kalignInputParams *const*)ptr, "ns1:kalignInputParams");
	case SOAP_TYPE_PointerTons1__glimmerInputParams:
		return soap_out_PointerTons1__glimmerInputParams(soap, tag, id, (struct ns1__glimmerInputParams *const*)ptr, "ns1:glimmerInputParams");
	case SOAP_TYPE_PointerTons1__genemarkhmmInputParams:
		return soap_out_PointerTons1__genemarkhmmInputParams(soap, tag, id, (struct ns1__genemarkhmmInputParams *const*)ptr, "ns1:genemarkhmmInputParams");
	case SOAP_TYPE_PointerTons1__fetchBatchInputParams:
		return soap_out_PointerTons1__fetchBatchInputParams(soap, tag, id, (struct ns1__fetchBatchInputParams *const*)ptr, "ns1:fetchBatchInputParams");
	case SOAP_TYPE_PointerTons1__fetchDataInputParams:
		return soap_out_PointerTons1__fetchDataInputParams(soap, tag, id, (struct ns1__fetchDataInputParams *const*)ptr, "ns1:fetchDataInputParams");
	case SOAP_TYPE_PointerTons1__clustalwInputParams:
		return soap_out_PointerTons1__clustalwInputParams(soap, tag, id, (struct ns1__clustalwInputParams *const*)ptr, "ns1:clustalwInputParams");
	case SOAP_TYPE_PointerTons1__centroidfoldInputParams:
		return soap_out_PointerTons1__centroidfoldInputParams(soap, tag, id, (struct ns1__centroidfoldInputParams *const*)ptr, "ns1:centroidfoldInputParams");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons1__blastInputParams:
		return soap_out_PointerTons1__blastInputParams(soap, tag, id, (struct ns1__blastInputParams *const*)ptr, "ns1:blastInputParams");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns1__getMultiResult:
		soap_serialize_ns1__getMultiResult(soap, (const struct ns1__getMultiResult *)ptr);
		break;
	case SOAP_TYPE_ns1__getMultiResultResponse:
		soap_serialize_ns1__getMultiResultResponse(soap, (const struct ns1__getMultiResultResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getResult:
		soap_serialize_ns1__getResult(soap, (const struct ns1__getResult *)ptr);
		break;
	case SOAP_TYPE_ns1__getResultResponse:
		soap_serialize_ns1__getResultResponse(soap, (const struct ns1__getResultResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__checkStatus_USCOREretJobid:
		soap_serialize_ns1__checkStatus_USCOREretJobid(soap, (const struct ns1__checkStatus_USCOREretJobid *)ptr);
		break;
	case SOAP_TYPE_ns1__checkStatus_USCOREretJobidResponse:
		soap_serialize_ns1__checkStatus_USCOREretJobidResponse(soap, (const struct ns1__checkStatus_USCOREretJobidResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__checkStatus:
		soap_serialize_ns1__checkStatus(soap, (const struct ns1__checkStatus *)ptr);
		break;
	case SOAP_TYPE_ns1__checkStatusResponse:
		soap_serialize_ns1__checkStatusResponse(soap, (const struct ns1__checkStatusResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__map2PathwayProjector:
		soap_serialize_ns1__map2PathwayProjector(soap, (const struct ns1__map2PathwayProjector *)ptr);
		break;
	case SOAP_TYPE_ns1__map2PathwayProjectorResponse:
		soap_serialize_ns1__map2PathwayProjectorResponse(soap, (const struct ns1__map2PathwayProjectorResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__showBlastDB:
		soap_serialize_ns1__showBlastDB(soap, (const struct ns1__showBlastDB *)ptr);
		break;
	case SOAP_TYPE_ns1__showBlastDBResponse:
		soap_serialize_ns1__showBlastDBResponse(soap, (const struct ns1__showBlastDBResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runRNAfold:
		soap_serialize_ns1__runRNAfold(soap, (const struct ns1__runRNAfold *)ptr);
		break;
	case SOAP_TYPE_ns1__runRNAfoldResponse:
		soap_serialize_ns1__runRNAfoldResponse(soap, (const struct ns1__runRNAfoldResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runWolfPsort:
		soap_serialize_ns1__runWolfPsort(soap, (const struct ns1__runWolfPsort *)ptr);
		break;
	case SOAP_TYPE_ns1__runWolfPsortResponse:
		soap_serialize_ns1__runWolfPsortResponse(soap, (const struct ns1__runWolfPsortResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runWeblogo:
		soap_serialize_ns1__runWeblogo(soap, (const struct ns1__runWeblogo *)ptr);
		break;
	case SOAP_TYPE_ns1__runWeblogoResponse:
		soap_serialize_ns1__runWeblogoResponse(soap, (const struct ns1__runWeblogoResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runtRNAscan:
		soap_serialize_ns1__runtRNAscan(soap, (const struct ns1__runtRNAscan *)ptr);
		break;
	case SOAP_TYPE_ns1__runtRNAscanResponse:
		soap_serialize_ns1__runtRNAscanResponse(soap, (const struct ns1__runtRNAscanResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runTcoffee:
		soap_serialize_ns1__runTcoffee(soap, (const struct ns1__runTcoffee *)ptr);
		break;
	case SOAP_TYPE_ns1__runTcoffeeResponse:
		soap_serialize_ns1__runTcoffeeResponse(soap, (const struct ns1__runTcoffeeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runSsearch:
		soap_serialize_ns1__runSsearch(soap, (const struct ns1__runSsearch *)ptr);
		break;
	case SOAP_TYPE_ns1__runSsearchResponse:
		soap_serialize_ns1__runSsearchResponse(soap, (const struct ns1__runSsearchResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runPsortb:
		soap_serialize_ns1__runPsortb(soap, (const struct ns1__runPsortb *)ptr);
		break;
	case SOAP_TYPE_ns1__runPsortbResponse:
		soap_serialize_ns1__runPsortbResponse(soap, (const struct ns1__runPsortbResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runPsort2:
		soap_serialize_ns1__runPsort2(soap, (const struct ns1__runPsort2 *)ptr);
		break;
	case SOAP_TYPE_ns1__runPsort2Response:
		soap_serialize_ns1__runPsort2Response(soap, (const struct ns1__runPsort2Response *)ptr);
		break;
	case SOAP_TYPE_ns1__runPsort:
		soap_serialize_ns1__runPsort(soap, (const struct ns1__runPsort *)ptr);
		break;
	case SOAP_TYPE_ns1__runPsortResponse:
		soap_serialize_ns1__runPsortResponse(soap, (const struct ns1__runPsortResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runDolpenny:
		soap_serialize_ns1__runDolpenny(soap, (const struct ns1__runDolpenny *)ptr);
		break;
	case SOAP_TYPE_ns1__runDolpennyResponse:
		soap_serialize_ns1__runDolpennyResponse(soap, (const struct ns1__runDolpennyResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runDollop:
		soap_serialize_ns1__runDollop(soap, (const struct ns1__runDollop *)ptr);
		break;
	case SOAP_TYPE_ns1__runDollopResponse:
		soap_serialize_ns1__runDollopResponse(soap, (const struct ns1__runDollopResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runPenny:
		soap_serialize_ns1__runPenny(soap, (const struct ns1__runPenny *)ptr);
		break;
	case SOAP_TYPE_ns1__runPennyResponse:
		soap_serialize_ns1__runPennyResponse(soap, (const struct ns1__runPennyResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runMix:
		soap_serialize_ns1__runMix(soap, (const struct ns1__runMix *)ptr);
		break;
	case SOAP_TYPE_ns1__runMixResponse:
		soap_serialize_ns1__runMixResponse(soap, (const struct ns1__runMixResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runContml:
		soap_serialize_ns1__runContml(soap, (const struct ns1__runContml *)ptr);
		break;
	case SOAP_TYPE_ns1__runContmlResponse:
		soap_serialize_ns1__runContmlResponse(soap, (const struct ns1__runContmlResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runNeighbor:
		soap_serialize_ns1__runNeighbor(soap, (const struct ns1__runNeighbor *)ptr);
		break;
	case SOAP_TYPE_ns1__runNeighborResponse:
		soap_serialize_ns1__runNeighborResponse(soap, (const struct ns1__runNeighborResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runKitsch:
		soap_serialize_ns1__runKitsch(soap, (const struct ns1__runKitsch *)ptr);
		break;
	case SOAP_TYPE_ns1__runKitschResponse:
		soap_serialize_ns1__runKitschResponse(soap, (const struct ns1__runKitschResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runFitch:
		soap_serialize_ns1__runFitch(soap, (const struct ns1__runFitch *)ptr);
		break;
	case SOAP_TYPE_ns1__runFitchResponse:
		soap_serialize_ns1__runFitchResponse(soap, (const struct ns1__runFitchResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runClique:
		soap_serialize_ns1__runClique(soap, (const struct ns1__runClique *)ptr);
		break;
	case SOAP_TYPE_ns1__runCliqueResponse:
		soap_serialize_ns1__runCliqueResponse(soap, (const struct ns1__runCliqueResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runRestml:
		soap_serialize_ns1__runRestml(soap, (const struct ns1__runRestml *)ptr);
		break;
	case SOAP_TYPE_ns1__runRestmlResponse:
		soap_serialize_ns1__runRestmlResponse(soap, (const struct ns1__runRestmlResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runSeqboot:
		soap_serialize_ns1__runSeqboot(soap, (const struct ns1__runSeqboot *)ptr);
		break;
	case SOAP_TYPE_ns1__runSeqbootResponse:
		soap_serialize_ns1__runSeqbootResponse(soap, (const struct ns1__runSeqbootResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runGendist:
		soap_serialize_ns1__runGendist(soap, (const struct ns1__runGendist *)ptr);
		break;
	case SOAP_TYPE_ns1__runGendistResponse:
		soap_serialize_ns1__runGendistResponse(soap, (const struct ns1__runGendistResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runDnadist:
		soap_serialize_ns1__runDnadist(soap, (const struct ns1__runDnadist *)ptr);
		break;
	case SOAP_TYPE_ns1__runDnadistResponse:
		soap_serialize_ns1__runDnadistResponse(soap, (const struct ns1__runDnadistResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runDnamlk:
		soap_serialize_ns1__runDnamlk(soap, (const struct ns1__runDnamlk *)ptr);
		break;
	case SOAP_TYPE_ns1__runDnamlkResponse:
		soap_serialize_ns1__runDnamlkResponse(soap, (const struct ns1__runDnamlkResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runDnaml:
		soap_serialize_ns1__runDnaml(soap, (const struct ns1__runDnaml *)ptr);
		break;
	case SOAP_TYPE_ns1__runDnamlResponse:
		soap_serialize_ns1__runDnamlResponse(soap, (const struct ns1__runDnamlResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runDnainvar:
		soap_serialize_ns1__runDnainvar(soap, (const struct ns1__runDnainvar *)ptr);
		break;
	case SOAP_TYPE_ns1__runDnainvarResponse:
		soap_serialize_ns1__runDnainvarResponse(soap, (const struct ns1__runDnainvarResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runDnacomp:
		soap_serialize_ns1__runDnacomp(soap, (const struct ns1__runDnacomp *)ptr);
		break;
	case SOAP_TYPE_ns1__runDnacompResponse:
		soap_serialize_ns1__runDnacompResponse(soap, (const struct ns1__runDnacompResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runDnapenny:
		soap_serialize_ns1__runDnapenny(soap, (const struct ns1__runDnapenny *)ptr);
		break;
	case SOAP_TYPE_ns1__runDnapennyResponse:
		soap_serialize_ns1__runDnapennyResponse(soap, (const struct ns1__runDnapennyResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runDnapars:
		soap_serialize_ns1__runDnapars(soap, (const struct ns1__runDnapars *)ptr);
		break;
	case SOAP_TYPE_ns1__runDnaparsResponse:
		soap_serialize_ns1__runDnaparsResponse(soap, (const struct ns1__runDnaparsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runProtdist:
		soap_serialize_ns1__runProtdist(soap, (const struct ns1__runProtdist *)ptr);
		break;
	case SOAP_TYPE_ns1__runProtdistResponse:
		soap_serialize_ns1__runProtdistResponse(soap, (const struct ns1__runProtdistResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runProtpars:
		soap_serialize_ns1__runProtpars(soap, (const struct ns1__runProtpars *)ptr);
		break;
	case SOAP_TYPE_ns1__runProtparsResponse:
		soap_serialize_ns1__runProtparsResponse(soap, (const struct ns1__runProtparsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runPhobius:
		soap_serialize_ns1__runPhobius(soap, (const struct ns1__runPhobius *)ptr);
		break;
	case SOAP_TYPE_ns1__runPhobiusResponse:
		soap_serialize_ns1__runPhobiusResponse(soap, (const struct ns1__runPhobiusResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runMuscle:
		soap_serialize_ns1__runMuscle(soap, (const struct ns1__runMuscle *)ptr);
		break;
	case SOAP_TYPE_ns1__runMuscleResponse:
		soap_serialize_ns1__runMuscleResponse(soap, (const struct ns1__runMuscleResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runMafft:
		soap_serialize_ns1__runMafft(soap, (const struct ns1__runMafft *)ptr);
		break;
	case SOAP_TYPE_ns1__runMafftResponse:
		soap_serialize_ns1__runMafftResponse(soap, (const struct ns1__runMafftResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runKalign:
		soap_serialize_ns1__runKalign(soap, (const struct ns1__runKalign *)ptr);
		break;
	case SOAP_TYPE_ns1__runKalignResponse:
		soap_serialize_ns1__runKalignResponse(soap, (const struct ns1__runKalignResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runGlimmer:
		soap_serialize_ns1__runGlimmer(soap, (const struct ns1__runGlimmer *)ptr);
		break;
	case SOAP_TYPE_ns1__runGlimmerResponse:
		soap_serialize_ns1__runGlimmerResponse(soap, (const struct ns1__runGlimmerResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runGenemarkhmm:
		soap_serialize_ns1__runGenemarkhmm(soap, (const struct ns1__runGenemarkhmm *)ptr);
		break;
	case SOAP_TYPE_ns1__runGenemarkhmmResponse:
		soap_serialize_ns1__runGenemarkhmmResponse(soap, (const struct ns1__runGenemarkhmmResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runFetchBatch:
		soap_serialize_ns1__runFetchBatch(soap, (const struct ns1__runFetchBatch *)ptr);
		break;
	case SOAP_TYPE_ns1__runFetchBatchResponse:
		soap_serialize_ns1__runFetchBatchResponse(soap, (const struct ns1__runFetchBatchResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runFetchData:
		soap_serialize_ns1__runFetchData(soap, (const struct ns1__runFetchData *)ptr);
		break;
	case SOAP_TYPE_ns1__runFetchDataResponse:
		soap_serialize_ns1__runFetchDataResponse(soap, (const struct ns1__runFetchDataResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runClustalw:
		soap_serialize_ns1__runClustalw(soap, (const struct ns1__runClustalw *)ptr);
		break;
	case SOAP_TYPE_ns1__runClustalwResponse:
		soap_serialize_ns1__runClustalwResponse(soap, (const struct ns1__runClustalwResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runCentroidfold:
		soap_serialize_ns1__runCentroidfold(soap, (const struct ns1__runCentroidfold *)ptr);
		break;
	case SOAP_TYPE_ns1__runCentroidfoldResponse:
		soap_serialize_ns1__runCentroidfoldResponse(soap, (const struct ns1__runCentroidfoldResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__runBlast:
		soap_serialize_ns1__runBlast(soap, (const struct ns1__runBlast *)ptr);
		break;
	case SOAP_TYPE_ns1__runBlastResponse:
		soap_serialize_ns1__runBlastResponse(soap, (const struct ns1__runBlastResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__showBlastDBInputParams:
		soap_serialize_ns1__showBlastDBInputParams(soap, (const struct ns1__showBlastDBInputParams *)ptr);
		break;
	case SOAP_TYPE_ns1__RNAfoldInputParams:
		soap_serialize_ns1__RNAfoldInputParams(soap, (const struct ns1__RNAfoldInputParams *)ptr);
		break;
	case SOAP_TYPE_ns1__wolfPsortInputParams:
		soap_serialize_ns1__wolfPsortInputParams(soap, (const struct ns1__wolfPsortInputParams *)ptr);
		break;
	case SOAP_TYPE_ns1__weblogoInputParams:
		soap_serialize_ns1__weblogoInputParams(soap, (const struct ns1__weblogoInputParams *)ptr);
		break;
	case SOAP_TYPE_ns1__ssearchInputParams:
		soap_serialize_ns1__ssearchInputParams(soap, (const struct ns1__ssearchInputParams *)ptr);
		break;
	case SOAP_TYPE_ns1__tRNAscanInputParams:
		soap_serialize_ns1__tRNAscanInputParams(soap, (const struct ns1__tRNAscanInputParams *)ptr);
		break;
	case SOAP_TYPE_ns1__tcoffeeInputParams:
		soap_serialize_ns1__tcoffeeInputParams(soap, (const struct ns1__tcoffeeInputParams *)ptr);
		break;
	case SOAP_TYPE_ns1__psortbInputParams:
		soap_serialize_ns1__psortbInputParams(soap, (const struct ns1__psortbInputParams *)ptr);
		break;
	case SOAP_TYPE_ns1__psortInputParams:
		soap_serialize_ns1__psortInputParams(soap, (const struct ns1__psortInputParams *)ptr);
		break;
	case SOAP_TYPE_ns1__phobiusInputParams:
		soap_serialize_ns1__phobiusInputParams(soap, (const struct ns1__phobiusInputParams *)ptr);
		break;
	case SOAP_TYPE_ns1__muscleInputParams:
		soap_serialize_ns1__muscleInputParams(soap, (const struct ns1__muscleInputParams *)ptr);
		break;
	case SOAP_TYPE_ns1__mafftInputParams:
		soap_serialize_ns1__mafftInputParams(soap, (const struct ns1__mafftInputParams *)ptr);
		break;
	case SOAP_TYPE_ns1__kalignInputParams:
		soap_serialize_ns1__kalignInputParams(soap, (const struct ns1__kalignInputParams *)ptr);
		break;
	case SOAP_TYPE_ns1__glimmerInputParams:
		soap_serialize_ns1__glimmerInputParams(soap, (const struct ns1__glimmerInputParams *)ptr);
		break;
	case SOAP_TYPE_ns1__genemarkhmmInputParams:
		soap_serialize_ns1__genemarkhmmInputParams(soap, (const struct ns1__genemarkhmmInputParams *)ptr);
		break;
	case SOAP_TYPE_ns1__fetchBatchInputParams:
		soap_serialize_ns1__fetchBatchInputParams(soap, (const struct ns1__fetchBatchInputParams *)ptr);
		break;
	case SOAP_TYPE_ns1__fetchDataInputParams:
		soap_serialize_ns1__fetchDataInputParams(soap, (const struct ns1__fetchDataInputParams *)ptr);
		break;
	case SOAP_TYPE_ns1__clustalwInputParams:
		soap_serialize_ns1__clustalwInputParams(soap, (const struct ns1__clustalwInputParams *)ptr);
		break;
	case SOAP_TYPE_ns1__centroidfoldInputParams:
		soap_serialize_ns1__centroidfoldInputParams(soap, (const struct ns1__centroidfoldInputParams *)ptr);
		break;
	case SOAP_TYPE_ns1__blastInputParams:
		soap_serialize_ns1__blastInputParams(soap, (const struct ns1__blastInputParams *)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__showBlastDBInputParams:
		soap_serialize_PointerTons1__showBlastDBInputParams(soap, (struct ns1__showBlastDBInputParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RNAfoldInputParams:
		soap_serialize_PointerTons1__RNAfoldInputParams(soap, (struct ns1__RNAfoldInputParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__wolfPsortInputParams:
		soap_serialize_PointerTons1__wolfPsortInputParams(soap, (struct ns1__wolfPsortInputParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__weblogoInputParams:
		soap_serialize_PointerTons1__weblogoInputParams(soap, (struct ns1__weblogoInputParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__tRNAscanInputParams:
		soap_serialize_PointerTons1__tRNAscanInputParams(soap, (struct ns1__tRNAscanInputParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__tcoffeeInputParams:
		soap_serialize_PointerTons1__tcoffeeInputParams(soap, (struct ns1__tcoffeeInputParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ssearchInputParams:
		soap_serialize_PointerTons1__ssearchInputParams(soap, (struct ns1__ssearchInputParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__psortbInputParams:
		soap_serialize_PointerTons1__psortbInputParams(soap, (struct ns1__psortbInputParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__psortInputParams:
		soap_serialize_PointerTons1__psortInputParams(soap, (struct ns1__psortInputParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__phobiusInputParams:
		soap_serialize_PointerTons1__phobiusInputParams(soap, (struct ns1__phobiusInputParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__muscleInputParams:
		soap_serialize_PointerTons1__muscleInputParams(soap, (struct ns1__muscleInputParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mafftInputParams:
		soap_serialize_PointerTons1__mafftInputParams(soap, (struct ns1__mafftInputParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__kalignInputParams:
		soap_serialize_PointerTons1__kalignInputParams(soap, (struct ns1__kalignInputParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__glimmerInputParams:
		soap_serialize_PointerTons1__glimmerInputParams(soap, (struct ns1__glimmerInputParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__genemarkhmmInputParams:
		soap_serialize_PointerTons1__genemarkhmmInputParams(soap, (struct ns1__genemarkhmmInputParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__fetchBatchInputParams:
		soap_serialize_PointerTons1__fetchBatchInputParams(soap, (struct ns1__fetchBatchInputParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__fetchDataInputParams:
		soap_serialize_PointerTons1__fetchDataInputParams(soap, (struct ns1__fetchDataInputParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__clustalwInputParams:
		soap_serialize_PointerTons1__clustalwInputParams(soap, (struct ns1__clustalwInputParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__centroidfoldInputParams:
		soap_serialize_PointerTons1__centroidfoldInputParams(soap, (struct ns1__centroidfoldInputParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__blastInputParams:
		soap_serialize_PointerTons1__blastInputParams(soap, (struct ns1__blastInputParams *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{	float *p;
	p = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__boolean(struct soap *soap, enum xsd__boolean *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__boolean
	*a = SOAP_DEFAULT_xsd__boolean;
#else
	*a = (enum xsd__boolean)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (soap_out_xsd__boolean(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (long)xsd__boolean__false_, "false" },
	{ (long)xsd__boolean__true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{	return soap_code_str(soap_codes_xsd__boolean, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getMultiResult(struct soap *soap, struct ns1__getMultiResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_jobid);
	soap_default_string(soap, &a->_type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getMultiResult(struct soap *soap, const struct ns1__getMultiResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_jobid);
	soap_serialize_string(soap, &a->_type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getMultiResult(struct soap *soap, const struct ns1__getMultiResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getMultiResult);
	if (soap_out_ns1__getMultiResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMultiResult(struct soap *soap, const char *tag, int id, const struct ns1__getMultiResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMultiResult), type))
		return soap->error;
	if (soap_out_string(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	if (soap_out_string(soap, "type", -1, &a->_type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getMultiResult * SOAP_FMAC4 soap_get_ns1__getMultiResult(struct soap *soap, struct ns1__getMultiResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMultiResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getMultiResult * SOAP_FMAC4 soap_in_ns1__getMultiResult(struct soap *soap, const char *tag, struct ns1__getMultiResult *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	size_t soap_flag__type = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getMultiResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMultiResult, sizeof(struct ns1__getMultiResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getMultiResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap_flag__type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_type, "xsd:string"))
				{	soap_flag__type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getMultiResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMultiResult, 0, sizeof(struct ns1__getMultiResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getMultiResultResponse(struct soap *soap, struct ns1__getMultiResultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getMultiResultResponse(struct soap *soap, const struct ns1__getMultiResultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getMultiResultResponse(struct soap *soap, const struct ns1__getMultiResultResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getMultiResultResponse);
	if (soap_out_ns1__getMultiResultResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMultiResultResponse(struct soap *soap, const char *tag, int id, const struct ns1__getMultiResultResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMultiResultResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "result", -1, &a->_result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getMultiResultResponse * SOAP_FMAC4 soap_get_ns1__getMultiResultResponse(struct soap *soap, struct ns1__getMultiResultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMultiResultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getMultiResultResponse * SOAP_FMAC4 soap_in_ns1__getMultiResultResponse(struct soap *soap, const char *tag, struct ns1__getMultiResultResponse *a, const char *type)
{
	size_t soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getMultiResultResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMultiResultResponse, sizeof(struct ns1__getMultiResultResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getMultiResultResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getMultiResultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMultiResultResponse, 0, sizeof(struct ns1__getMultiResultResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getResult(struct soap *soap, struct ns1__getResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_jobid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getResult(struct soap *soap, const struct ns1__getResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getResult(struct soap *soap, const struct ns1__getResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getResult);
	if (soap_out_ns1__getResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getResult(struct soap *soap, const char *tag, int id, const struct ns1__getResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getResult), type))
		return soap->error;
	if (soap_out_string(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getResult * SOAP_FMAC4 soap_get_ns1__getResult(struct soap *soap, struct ns1__getResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getResult * SOAP_FMAC4 soap_in_ns1__getResult(struct soap *soap, const char *tag, struct ns1__getResult *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getResult, sizeof(struct ns1__getResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getResult, 0, sizeof(struct ns1__getResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getResultResponse(struct soap *soap, struct ns1__getResultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getResultResponse(struct soap *soap, const struct ns1__getResultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getResultResponse(struct soap *soap, const struct ns1__getResultResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getResultResponse);
	if (soap_out_ns1__getResultResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getResultResponse(struct soap *soap, const char *tag, int id, const struct ns1__getResultResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getResultResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "result", -1, &a->_result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getResultResponse * SOAP_FMAC4 soap_get_ns1__getResultResponse(struct soap *soap, struct ns1__getResultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getResultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getResultResponse * SOAP_FMAC4 soap_in_ns1__getResultResponse(struct soap *soap, const char *tag, struct ns1__getResultResponse *a, const char *type)
{
	size_t soap_flag__result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getResultResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getResultResponse, sizeof(struct ns1__getResultResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getResultResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_result, "xsd:string"))
				{	soap_flag__result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getResultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getResultResponse, 0, sizeof(struct ns1__getResultResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__checkStatus_USCOREretJobid(struct soap *soap, struct ns1__checkStatus_USCOREretJobid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_jobid_USCOREin);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__checkStatus_USCOREretJobid(struct soap *soap, const struct ns1__checkStatus_USCOREretJobid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_jobid_USCOREin);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__checkStatus_USCOREretJobid(struct soap *soap, const struct ns1__checkStatus_USCOREretJobid *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__checkStatus_USCOREretJobid);
	if (soap_out_ns1__checkStatus_USCOREretJobid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkStatus_USCOREretJobid(struct soap *soap, const char *tag, int id, const struct ns1__checkStatus_USCOREretJobid *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkStatus_USCOREretJobid), type))
		return soap->error;
	if (soap_out_string(soap, "jobid_in", -1, &a->_jobid_USCOREin, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__checkStatus_USCOREretJobid * SOAP_FMAC4 soap_get_ns1__checkStatus_USCOREretJobid(struct soap *soap, struct ns1__checkStatus_USCOREretJobid *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkStatus_USCOREretJobid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__checkStatus_USCOREretJobid * SOAP_FMAC4 soap_in_ns1__checkStatus_USCOREretJobid(struct soap *soap, const char *tag, struct ns1__checkStatus_USCOREretJobid *a, const char *type)
{
	size_t soap_flag__jobid_USCOREin = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__checkStatus_USCOREretJobid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkStatus_USCOREretJobid, sizeof(struct ns1__checkStatus_USCOREretJobid), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__checkStatus_USCOREretJobid(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid_USCOREin && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_jobid_USCOREin, "xsd:string"))
				{	soap_flag__jobid_USCOREin--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__checkStatus_USCOREretJobid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkStatus_USCOREretJobid, 0, sizeof(struct ns1__checkStatus_USCOREretJobid), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__checkStatus_USCOREretJobidResponse(struct soap *soap, struct ns1__checkStatus_USCOREretJobidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid_USCOREout = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__checkStatus_USCOREretJobidResponse(struct soap *soap, const struct ns1__checkStatus_USCOREretJobidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid_USCOREout);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__checkStatus_USCOREretJobidResponse(struct soap *soap, const struct ns1__checkStatus_USCOREretJobidResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__checkStatus_USCOREretJobidResponse);
	if (soap_out_ns1__checkStatus_USCOREretJobidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkStatus_USCOREretJobidResponse(struct soap *soap, const char *tag, int id, const struct ns1__checkStatus_USCOREretJobidResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkStatus_USCOREretJobidResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid_out", -1, &a->_jobid_USCOREout, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__checkStatus_USCOREretJobidResponse * SOAP_FMAC4 soap_get_ns1__checkStatus_USCOREretJobidResponse(struct soap *soap, struct ns1__checkStatus_USCOREretJobidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkStatus_USCOREretJobidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__checkStatus_USCOREretJobidResponse * SOAP_FMAC4 soap_in_ns1__checkStatus_USCOREretJobidResponse(struct soap *soap, const char *tag, struct ns1__checkStatus_USCOREretJobidResponse *a, const char *type)
{
	size_t soap_flag__jobid_USCOREout = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__checkStatus_USCOREretJobidResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkStatus_USCOREretJobidResponse, sizeof(struct ns1__checkStatus_USCOREretJobidResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__checkStatus_USCOREretJobidResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid_USCOREout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid_USCOREout, "xsd:string"))
				{	soap_flag__jobid_USCOREout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__checkStatus_USCOREretJobidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkStatus_USCOREretJobidResponse, 0, sizeof(struct ns1__checkStatus_USCOREretJobidResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__checkStatus(struct soap *soap, struct ns1__checkStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_jobid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__checkStatus(struct soap *soap, const struct ns1__checkStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__checkStatus(struct soap *soap, const struct ns1__checkStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__checkStatus);
	if (soap_out_ns1__checkStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkStatus(struct soap *soap, const char *tag, int id, const struct ns1__checkStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkStatus), type))
		return soap->error;
	if (soap_out_string(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__checkStatus * SOAP_FMAC4 soap_get_ns1__checkStatus(struct soap *soap, struct ns1__checkStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__checkStatus * SOAP_FMAC4 soap_in_ns1__checkStatus(struct soap *soap, const char *tag, struct ns1__checkStatus *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__checkStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkStatus, sizeof(struct ns1__checkStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__checkStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__checkStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkStatus, 0, sizeof(struct ns1__checkStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__checkStatusResponse(struct soap *soap, struct ns1__checkStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_status = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__checkStatusResponse(struct soap *soap, const struct ns1__checkStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->_status);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__checkStatusResponse(struct soap *soap, const struct ns1__checkStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__checkStatusResponse);
	if (soap_out_ns1__checkStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkStatusResponse(struct soap *soap, const char *tag, int id, const struct ns1__checkStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkStatusResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "status", -1, &a->_status, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__checkStatusResponse * SOAP_FMAC4 soap_get_ns1__checkStatusResponse(struct soap *soap, struct ns1__checkStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__checkStatusResponse * SOAP_FMAC4 soap_in_ns1__checkStatusResponse(struct soap *soap, const char *tag, struct ns1__checkStatusResponse *a, const char *type)
{
	size_t soap_flag__status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__checkStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkStatusResponse, sizeof(struct ns1__checkStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__checkStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, NULL, &a->_status, "xsd:int"))
				{	soap_flag__status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__checkStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkStatusResponse, 0, sizeof(struct ns1__checkStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__map2PathwayProjector(struct soap *soap, struct ns1__map2PathwayProjector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__map2PathwayProjector(struct soap *soap, const struct ns1__map2PathwayProjector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__map2PathwayProjector(struct soap *soap, const struct ns1__map2PathwayProjector *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__map2PathwayProjector);
	if (soap_out_ns1__map2PathwayProjector(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__map2PathwayProjector(struct soap *soap, const char *tag, int id, const struct ns1__map2PathwayProjector *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__map2PathwayProjector), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__map2PathwayProjector * SOAP_FMAC4 soap_get_ns1__map2PathwayProjector(struct soap *soap, struct ns1__map2PathwayProjector *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__map2PathwayProjector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__map2PathwayProjector * SOAP_FMAC4 soap_in_ns1__map2PathwayProjector(struct soap *soap, const char *tag, struct ns1__map2PathwayProjector *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__map2PathwayProjector *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__map2PathwayProjector, sizeof(struct ns1__map2PathwayProjector), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__map2PathwayProjector(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__map2PathwayProjector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__map2PathwayProjector, 0, sizeof(struct ns1__map2PathwayProjector), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__map2PathwayProjectorResponse(struct soap *soap, struct ns1__map2PathwayProjectorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__map2PathwayProjectorResponse(struct soap *soap, const struct ns1__map2PathwayProjectorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__map2PathwayProjectorResponse(struct soap *soap, const struct ns1__map2PathwayProjectorResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__map2PathwayProjectorResponse);
	if (soap_out_ns1__map2PathwayProjectorResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__map2PathwayProjectorResponse(struct soap *soap, const char *tag, int id, const struct ns1__map2PathwayProjectorResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__map2PathwayProjectorResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__map2PathwayProjectorResponse * SOAP_FMAC4 soap_get_ns1__map2PathwayProjectorResponse(struct soap *soap, struct ns1__map2PathwayProjectorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__map2PathwayProjectorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__map2PathwayProjectorResponse * SOAP_FMAC4 soap_in_ns1__map2PathwayProjectorResponse(struct soap *soap, const char *tag, struct ns1__map2PathwayProjectorResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__map2PathwayProjectorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__map2PathwayProjectorResponse, sizeof(struct ns1__map2PathwayProjectorResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__map2PathwayProjectorResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__map2PathwayProjectorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__map2PathwayProjectorResponse, 0, sizeof(struct ns1__map2PathwayProjectorResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__showBlastDB(struct soap *soap, struct ns1__showBlastDB *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_params = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__showBlastDB(struct soap *soap, const struct ns1__showBlastDB *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__showBlastDBInputParams(soap, &a->_params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__showBlastDB(struct soap *soap, const struct ns1__showBlastDB *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__showBlastDB);
	if (soap_out_ns1__showBlastDB(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__showBlastDB(struct soap *soap, const char *tag, int id, const struct ns1__showBlastDB *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__showBlastDB), type))
		return soap->error;
	if (soap_out_PointerTons1__showBlastDBInputParams(soap, "params", -1, &a->_params, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__showBlastDB * SOAP_FMAC4 soap_get_ns1__showBlastDB(struct soap *soap, struct ns1__showBlastDB *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__showBlastDB(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__showBlastDB * SOAP_FMAC4 soap_in_ns1__showBlastDB(struct soap *soap, const char *tag, struct ns1__showBlastDB *a, const char *type)
{
	size_t soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__showBlastDB *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__showBlastDB, sizeof(struct ns1__showBlastDB), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__showBlastDB(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__showBlastDBInputParams(soap, NULL, &a->_params, "ns1:showBlastDBInputParams"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__showBlastDB *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__showBlastDB, 0, sizeof(struct ns1__showBlastDB), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__showBlastDBResponse(struct soap *soap, struct ns1__showBlastDBResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_dblist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__showBlastDBResponse(struct soap *soap, const struct ns1__showBlastDBResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_dblist);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__showBlastDBResponse(struct soap *soap, const struct ns1__showBlastDBResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__showBlastDBResponse);
	if (soap_out_ns1__showBlastDBResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__showBlastDBResponse(struct soap *soap, const char *tag, int id, const struct ns1__showBlastDBResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__showBlastDBResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "dblist", -1, &a->_dblist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__showBlastDBResponse * SOAP_FMAC4 soap_get_ns1__showBlastDBResponse(struct soap *soap, struct ns1__showBlastDBResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__showBlastDBResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__showBlastDBResponse * SOAP_FMAC4 soap_in_ns1__showBlastDBResponse(struct soap *soap, const char *tag, struct ns1__showBlastDBResponse *a, const char *type)
{
	size_t soap_flag__dblist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__showBlastDBResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__showBlastDBResponse, sizeof(struct ns1__showBlastDBResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__showBlastDBResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__dblist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_dblist, "xsd:string"))
				{	soap_flag__dblist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__showBlastDBResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__showBlastDBResponse, 0, sizeof(struct ns1__showBlastDBResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runRNAfold(struct soap *soap, struct ns1__runRNAfold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
	a->_params = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runRNAfold(struct soap *soap, const struct ns1__runRNAfold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
	soap_serialize_PointerTons1__RNAfoldInputParams(soap, &a->_params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runRNAfold(struct soap *soap, const struct ns1__runRNAfold *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runRNAfold);
	if (soap_out_ns1__runRNAfold(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runRNAfold(struct soap *soap, const char *tag, int id, const struct ns1__runRNAfold *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runRNAfold), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_PointerTons1__RNAfoldInputParams(soap, "params", -1, &a->_params, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runRNAfold * SOAP_FMAC4 soap_get_ns1__runRNAfold(struct soap *soap, struct ns1__runRNAfold *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runRNAfold(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runRNAfold * SOAP_FMAC4 soap_in_ns1__runRNAfold(struct soap *soap, const char *tag, struct ns1__runRNAfold *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runRNAfold *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runRNAfold, sizeof(struct ns1__runRNAfold), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runRNAfold(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RNAfoldInputParams(soap, NULL, &a->_params, "ns1:RNAfoldInputParams"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runRNAfold *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runRNAfold, 0, sizeof(struct ns1__runRNAfold), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runRNAfoldResponse(struct soap *soap, struct ns1__runRNAfoldResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runRNAfoldResponse(struct soap *soap, const struct ns1__runRNAfoldResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runRNAfoldResponse(struct soap *soap, const struct ns1__runRNAfoldResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runRNAfoldResponse);
	if (soap_out_ns1__runRNAfoldResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runRNAfoldResponse(struct soap *soap, const char *tag, int id, const struct ns1__runRNAfoldResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runRNAfoldResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runRNAfoldResponse * SOAP_FMAC4 soap_get_ns1__runRNAfoldResponse(struct soap *soap, struct ns1__runRNAfoldResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runRNAfoldResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runRNAfoldResponse * SOAP_FMAC4 soap_in_ns1__runRNAfoldResponse(struct soap *soap, const char *tag, struct ns1__runRNAfoldResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runRNAfoldResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runRNAfoldResponse, sizeof(struct ns1__runRNAfoldResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runRNAfoldResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runRNAfoldResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runRNAfoldResponse, 0, sizeof(struct ns1__runRNAfoldResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runWolfPsort(struct soap *soap, struct ns1__runWolfPsort *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
	a->_params = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runWolfPsort(struct soap *soap, const struct ns1__runWolfPsort *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
	soap_serialize_PointerTons1__wolfPsortInputParams(soap, &a->_params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runWolfPsort(struct soap *soap, const struct ns1__runWolfPsort *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runWolfPsort);
	if (soap_out_ns1__runWolfPsort(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runWolfPsort(struct soap *soap, const char *tag, int id, const struct ns1__runWolfPsort *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runWolfPsort), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_PointerTons1__wolfPsortInputParams(soap, "params", -1, &a->_params, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runWolfPsort * SOAP_FMAC4 soap_get_ns1__runWolfPsort(struct soap *soap, struct ns1__runWolfPsort *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runWolfPsort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runWolfPsort * SOAP_FMAC4 soap_in_ns1__runWolfPsort(struct soap *soap, const char *tag, struct ns1__runWolfPsort *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runWolfPsort *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runWolfPsort, sizeof(struct ns1__runWolfPsort), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runWolfPsort(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wolfPsortInputParams(soap, NULL, &a->_params, "ns1:wolfPsortInputParams"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runWolfPsort *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runWolfPsort, 0, sizeof(struct ns1__runWolfPsort), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runWolfPsortResponse(struct soap *soap, struct ns1__runWolfPsortResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runWolfPsortResponse(struct soap *soap, const struct ns1__runWolfPsortResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runWolfPsortResponse(struct soap *soap, const struct ns1__runWolfPsortResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runWolfPsortResponse);
	if (soap_out_ns1__runWolfPsortResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runWolfPsortResponse(struct soap *soap, const char *tag, int id, const struct ns1__runWolfPsortResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runWolfPsortResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runWolfPsortResponse * SOAP_FMAC4 soap_get_ns1__runWolfPsortResponse(struct soap *soap, struct ns1__runWolfPsortResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runWolfPsortResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runWolfPsortResponse * SOAP_FMAC4 soap_in_ns1__runWolfPsortResponse(struct soap *soap, const char *tag, struct ns1__runWolfPsortResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runWolfPsortResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runWolfPsortResponse, sizeof(struct ns1__runWolfPsortResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runWolfPsortResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runWolfPsortResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runWolfPsortResponse, 0, sizeof(struct ns1__runWolfPsortResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runWeblogo(struct soap *soap, struct ns1__runWeblogo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
	a->_params = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runWeblogo(struct soap *soap, const struct ns1__runWeblogo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
	soap_serialize_PointerTons1__weblogoInputParams(soap, &a->_params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runWeblogo(struct soap *soap, const struct ns1__runWeblogo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runWeblogo);
	if (soap_out_ns1__runWeblogo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runWeblogo(struct soap *soap, const char *tag, int id, const struct ns1__runWeblogo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runWeblogo), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_PointerTons1__weblogoInputParams(soap, "params", -1, &a->_params, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runWeblogo * SOAP_FMAC4 soap_get_ns1__runWeblogo(struct soap *soap, struct ns1__runWeblogo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runWeblogo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runWeblogo * SOAP_FMAC4 soap_in_ns1__runWeblogo(struct soap *soap, const char *tag, struct ns1__runWeblogo *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runWeblogo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runWeblogo, sizeof(struct ns1__runWeblogo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runWeblogo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__weblogoInputParams(soap, NULL, &a->_params, "ns1:weblogoInputParams"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runWeblogo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runWeblogo, 0, sizeof(struct ns1__runWeblogo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runWeblogoResponse(struct soap *soap, struct ns1__runWeblogoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runWeblogoResponse(struct soap *soap, const struct ns1__runWeblogoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runWeblogoResponse(struct soap *soap, const struct ns1__runWeblogoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runWeblogoResponse);
	if (soap_out_ns1__runWeblogoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runWeblogoResponse(struct soap *soap, const char *tag, int id, const struct ns1__runWeblogoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runWeblogoResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runWeblogoResponse * SOAP_FMAC4 soap_get_ns1__runWeblogoResponse(struct soap *soap, struct ns1__runWeblogoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runWeblogoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runWeblogoResponse * SOAP_FMAC4 soap_in_ns1__runWeblogoResponse(struct soap *soap, const char *tag, struct ns1__runWeblogoResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runWeblogoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runWeblogoResponse, sizeof(struct ns1__runWeblogoResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runWeblogoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runWeblogoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runWeblogoResponse, 0, sizeof(struct ns1__runWeblogoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runtRNAscan(struct soap *soap, struct ns1__runtRNAscan *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
	a->_params = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runtRNAscan(struct soap *soap, const struct ns1__runtRNAscan *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
	soap_serialize_PointerTons1__tRNAscanInputParams(soap, &a->_params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runtRNAscan(struct soap *soap, const struct ns1__runtRNAscan *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runtRNAscan);
	if (soap_out_ns1__runtRNAscan(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runtRNAscan(struct soap *soap, const char *tag, int id, const struct ns1__runtRNAscan *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runtRNAscan), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_PointerTons1__tRNAscanInputParams(soap, "params", -1, &a->_params, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runtRNAscan * SOAP_FMAC4 soap_get_ns1__runtRNAscan(struct soap *soap, struct ns1__runtRNAscan *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runtRNAscan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runtRNAscan * SOAP_FMAC4 soap_in_ns1__runtRNAscan(struct soap *soap, const char *tag, struct ns1__runtRNAscan *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runtRNAscan *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runtRNAscan, sizeof(struct ns1__runtRNAscan), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runtRNAscan(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__tRNAscanInputParams(soap, NULL, &a->_params, "ns1:tRNAscanInputParams"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runtRNAscan *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runtRNAscan, 0, sizeof(struct ns1__runtRNAscan), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runtRNAscanResponse(struct soap *soap, struct ns1__runtRNAscanResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runtRNAscanResponse(struct soap *soap, const struct ns1__runtRNAscanResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runtRNAscanResponse(struct soap *soap, const struct ns1__runtRNAscanResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runtRNAscanResponse);
	if (soap_out_ns1__runtRNAscanResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runtRNAscanResponse(struct soap *soap, const char *tag, int id, const struct ns1__runtRNAscanResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runtRNAscanResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runtRNAscanResponse * SOAP_FMAC4 soap_get_ns1__runtRNAscanResponse(struct soap *soap, struct ns1__runtRNAscanResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runtRNAscanResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runtRNAscanResponse * SOAP_FMAC4 soap_in_ns1__runtRNAscanResponse(struct soap *soap, const char *tag, struct ns1__runtRNAscanResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runtRNAscanResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runtRNAscanResponse, sizeof(struct ns1__runtRNAscanResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runtRNAscanResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runtRNAscanResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runtRNAscanResponse, 0, sizeof(struct ns1__runtRNAscanResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runTcoffee(struct soap *soap, struct ns1__runTcoffee *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
	a->_params = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runTcoffee(struct soap *soap, const struct ns1__runTcoffee *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
	soap_serialize_PointerTons1__tcoffeeInputParams(soap, &a->_params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runTcoffee(struct soap *soap, const struct ns1__runTcoffee *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runTcoffee);
	if (soap_out_ns1__runTcoffee(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runTcoffee(struct soap *soap, const char *tag, int id, const struct ns1__runTcoffee *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runTcoffee), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_PointerTons1__tcoffeeInputParams(soap, "params", -1, &a->_params, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runTcoffee * SOAP_FMAC4 soap_get_ns1__runTcoffee(struct soap *soap, struct ns1__runTcoffee *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runTcoffee(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runTcoffee * SOAP_FMAC4 soap_in_ns1__runTcoffee(struct soap *soap, const char *tag, struct ns1__runTcoffee *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runTcoffee *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runTcoffee, sizeof(struct ns1__runTcoffee), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runTcoffee(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__tcoffeeInputParams(soap, NULL, &a->_params, "ns1:tcoffeeInputParams"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runTcoffee *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runTcoffee, 0, sizeof(struct ns1__runTcoffee), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runTcoffeeResponse(struct soap *soap, struct ns1__runTcoffeeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runTcoffeeResponse(struct soap *soap, const struct ns1__runTcoffeeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runTcoffeeResponse(struct soap *soap, const struct ns1__runTcoffeeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runTcoffeeResponse);
	if (soap_out_ns1__runTcoffeeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runTcoffeeResponse(struct soap *soap, const char *tag, int id, const struct ns1__runTcoffeeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runTcoffeeResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runTcoffeeResponse * SOAP_FMAC4 soap_get_ns1__runTcoffeeResponse(struct soap *soap, struct ns1__runTcoffeeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runTcoffeeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runTcoffeeResponse * SOAP_FMAC4 soap_in_ns1__runTcoffeeResponse(struct soap *soap, const char *tag, struct ns1__runTcoffeeResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runTcoffeeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runTcoffeeResponse, sizeof(struct ns1__runTcoffeeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runTcoffeeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runTcoffeeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runTcoffeeResponse, 0, sizeof(struct ns1__runTcoffeeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runSsearch(struct soap *soap, struct ns1__runSsearch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
	a->_params = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runSsearch(struct soap *soap, const struct ns1__runSsearch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
	soap_serialize_PointerTons1__ssearchInputParams(soap, &a->_params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runSsearch(struct soap *soap, const struct ns1__runSsearch *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runSsearch);
	if (soap_out_ns1__runSsearch(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runSsearch(struct soap *soap, const char *tag, int id, const struct ns1__runSsearch *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runSsearch), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_PointerTons1__ssearchInputParams(soap, "params", -1, &a->_params, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runSsearch * SOAP_FMAC4 soap_get_ns1__runSsearch(struct soap *soap, struct ns1__runSsearch *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runSsearch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runSsearch * SOAP_FMAC4 soap_in_ns1__runSsearch(struct soap *soap, const char *tag, struct ns1__runSsearch *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runSsearch *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runSsearch, sizeof(struct ns1__runSsearch), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runSsearch(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ssearchInputParams(soap, NULL, &a->_params, "ns1:ssearchInputParams"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runSsearch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runSsearch, 0, sizeof(struct ns1__runSsearch), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runSsearchResponse(struct soap *soap, struct ns1__runSsearchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runSsearchResponse(struct soap *soap, const struct ns1__runSsearchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runSsearchResponse(struct soap *soap, const struct ns1__runSsearchResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runSsearchResponse);
	if (soap_out_ns1__runSsearchResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runSsearchResponse(struct soap *soap, const char *tag, int id, const struct ns1__runSsearchResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runSsearchResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runSsearchResponse * SOAP_FMAC4 soap_get_ns1__runSsearchResponse(struct soap *soap, struct ns1__runSsearchResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runSsearchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runSsearchResponse * SOAP_FMAC4 soap_in_ns1__runSsearchResponse(struct soap *soap, const char *tag, struct ns1__runSsearchResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runSsearchResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runSsearchResponse, sizeof(struct ns1__runSsearchResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runSsearchResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runSsearchResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runSsearchResponse, 0, sizeof(struct ns1__runSsearchResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runPsortb(struct soap *soap, struct ns1__runPsortb *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
	a->_params = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runPsortb(struct soap *soap, const struct ns1__runPsortb *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
	soap_serialize_PointerTons1__psortbInputParams(soap, &a->_params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runPsortb(struct soap *soap, const struct ns1__runPsortb *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runPsortb);
	if (soap_out_ns1__runPsortb(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runPsortb(struct soap *soap, const char *tag, int id, const struct ns1__runPsortb *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runPsortb), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_PointerTons1__psortbInputParams(soap, "params", -1, &a->_params, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runPsortb * SOAP_FMAC4 soap_get_ns1__runPsortb(struct soap *soap, struct ns1__runPsortb *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runPsortb(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runPsortb * SOAP_FMAC4 soap_in_ns1__runPsortb(struct soap *soap, const char *tag, struct ns1__runPsortb *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runPsortb *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runPsortb, sizeof(struct ns1__runPsortb), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runPsortb(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__psortbInputParams(soap, NULL, &a->_params, "ns1:psortbInputParams"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runPsortb *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runPsortb, 0, sizeof(struct ns1__runPsortb), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runPsortbResponse(struct soap *soap, struct ns1__runPsortbResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runPsortbResponse(struct soap *soap, const struct ns1__runPsortbResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runPsortbResponse(struct soap *soap, const struct ns1__runPsortbResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runPsortbResponse);
	if (soap_out_ns1__runPsortbResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runPsortbResponse(struct soap *soap, const char *tag, int id, const struct ns1__runPsortbResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runPsortbResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runPsortbResponse * SOAP_FMAC4 soap_get_ns1__runPsortbResponse(struct soap *soap, struct ns1__runPsortbResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runPsortbResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runPsortbResponse * SOAP_FMAC4 soap_in_ns1__runPsortbResponse(struct soap *soap, const char *tag, struct ns1__runPsortbResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runPsortbResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runPsortbResponse, sizeof(struct ns1__runPsortbResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runPsortbResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runPsortbResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runPsortbResponse, 0, sizeof(struct ns1__runPsortbResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runPsort2(struct soap *soap, struct ns1__runPsort2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runPsort2(struct soap *soap, const struct ns1__runPsort2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runPsort2(struct soap *soap, const struct ns1__runPsort2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runPsort2);
	if (soap_out_ns1__runPsort2(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runPsort2(struct soap *soap, const char *tag, int id, const struct ns1__runPsort2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runPsort2), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runPsort2 * SOAP_FMAC4 soap_get_ns1__runPsort2(struct soap *soap, struct ns1__runPsort2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runPsort2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runPsort2 * SOAP_FMAC4 soap_in_ns1__runPsort2(struct soap *soap, const char *tag, struct ns1__runPsort2 *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runPsort2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runPsort2, sizeof(struct ns1__runPsort2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runPsort2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runPsort2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runPsort2, 0, sizeof(struct ns1__runPsort2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runPsort2Response(struct soap *soap, struct ns1__runPsort2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runPsort2Response(struct soap *soap, const struct ns1__runPsort2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runPsort2Response(struct soap *soap, const struct ns1__runPsort2Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runPsort2Response);
	if (soap_out_ns1__runPsort2Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runPsort2Response(struct soap *soap, const char *tag, int id, const struct ns1__runPsort2Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runPsort2Response), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runPsort2Response * SOAP_FMAC4 soap_get_ns1__runPsort2Response(struct soap *soap, struct ns1__runPsort2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runPsort2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runPsort2Response * SOAP_FMAC4 soap_in_ns1__runPsort2Response(struct soap *soap, const char *tag, struct ns1__runPsort2Response *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runPsort2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runPsort2Response, sizeof(struct ns1__runPsort2Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runPsort2Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runPsort2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runPsort2Response, 0, sizeof(struct ns1__runPsort2Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runPsort(struct soap *soap, struct ns1__runPsort *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
	a->_params = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runPsort(struct soap *soap, const struct ns1__runPsort *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
	soap_serialize_PointerTons1__psortInputParams(soap, &a->_params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runPsort(struct soap *soap, const struct ns1__runPsort *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runPsort);
	if (soap_out_ns1__runPsort(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runPsort(struct soap *soap, const char *tag, int id, const struct ns1__runPsort *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runPsort), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_PointerTons1__psortInputParams(soap, "params", -1, &a->_params, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runPsort * SOAP_FMAC4 soap_get_ns1__runPsort(struct soap *soap, struct ns1__runPsort *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runPsort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runPsort * SOAP_FMAC4 soap_in_ns1__runPsort(struct soap *soap, const char *tag, struct ns1__runPsort *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runPsort *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runPsort, sizeof(struct ns1__runPsort), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runPsort(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__psortInputParams(soap, NULL, &a->_params, "ns1:psortInputParams"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runPsort *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runPsort, 0, sizeof(struct ns1__runPsort), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runPsortResponse(struct soap *soap, struct ns1__runPsortResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runPsortResponse(struct soap *soap, const struct ns1__runPsortResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runPsortResponse(struct soap *soap, const struct ns1__runPsortResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runPsortResponse);
	if (soap_out_ns1__runPsortResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runPsortResponse(struct soap *soap, const char *tag, int id, const struct ns1__runPsortResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runPsortResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runPsortResponse * SOAP_FMAC4 soap_get_ns1__runPsortResponse(struct soap *soap, struct ns1__runPsortResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runPsortResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runPsortResponse * SOAP_FMAC4 soap_in_ns1__runPsortResponse(struct soap *soap, const char *tag, struct ns1__runPsortResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runPsortResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runPsortResponse, sizeof(struct ns1__runPsortResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runPsortResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runPsortResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runPsortResponse, 0, sizeof(struct ns1__runPsortResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runDolpenny(struct soap *soap, struct ns1__runDolpenny *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runDolpenny(struct soap *soap, const struct ns1__runDolpenny *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runDolpenny(struct soap *soap, const struct ns1__runDolpenny *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runDolpenny);
	if (soap_out_ns1__runDolpenny(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runDolpenny(struct soap *soap, const char *tag, int id, const struct ns1__runDolpenny *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runDolpenny), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runDolpenny * SOAP_FMAC4 soap_get_ns1__runDolpenny(struct soap *soap, struct ns1__runDolpenny *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runDolpenny(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runDolpenny * SOAP_FMAC4 soap_in_ns1__runDolpenny(struct soap *soap, const char *tag, struct ns1__runDolpenny *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runDolpenny *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runDolpenny, sizeof(struct ns1__runDolpenny), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runDolpenny(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runDolpenny *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runDolpenny, 0, sizeof(struct ns1__runDolpenny), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runDolpennyResponse(struct soap *soap, struct ns1__runDolpennyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runDolpennyResponse(struct soap *soap, const struct ns1__runDolpennyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runDolpennyResponse(struct soap *soap, const struct ns1__runDolpennyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runDolpennyResponse);
	if (soap_out_ns1__runDolpennyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runDolpennyResponse(struct soap *soap, const char *tag, int id, const struct ns1__runDolpennyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runDolpennyResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runDolpennyResponse * SOAP_FMAC4 soap_get_ns1__runDolpennyResponse(struct soap *soap, struct ns1__runDolpennyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runDolpennyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runDolpennyResponse * SOAP_FMAC4 soap_in_ns1__runDolpennyResponse(struct soap *soap, const char *tag, struct ns1__runDolpennyResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runDolpennyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runDolpennyResponse, sizeof(struct ns1__runDolpennyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runDolpennyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runDolpennyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runDolpennyResponse, 0, sizeof(struct ns1__runDolpennyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runDollop(struct soap *soap, struct ns1__runDollop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runDollop(struct soap *soap, const struct ns1__runDollop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runDollop(struct soap *soap, const struct ns1__runDollop *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runDollop);
	if (soap_out_ns1__runDollop(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runDollop(struct soap *soap, const char *tag, int id, const struct ns1__runDollop *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runDollop), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runDollop * SOAP_FMAC4 soap_get_ns1__runDollop(struct soap *soap, struct ns1__runDollop *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runDollop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runDollop * SOAP_FMAC4 soap_in_ns1__runDollop(struct soap *soap, const char *tag, struct ns1__runDollop *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runDollop *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runDollop, sizeof(struct ns1__runDollop), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runDollop(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runDollop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runDollop, 0, sizeof(struct ns1__runDollop), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runDollopResponse(struct soap *soap, struct ns1__runDollopResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runDollopResponse(struct soap *soap, const struct ns1__runDollopResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runDollopResponse(struct soap *soap, const struct ns1__runDollopResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runDollopResponse);
	if (soap_out_ns1__runDollopResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runDollopResponse(struct soap *soap, const char *tag, int id, const struct ns1__runDollopResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runDollopResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runDollopResponse * SOAP_FMAC4 soap_get_ns1__runDollopResponse(struct soap *soap, struct ns1__runDollopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runDollopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runDollopResponse * SOAP_FMAC4 soap_in_ns1__runDollopResponse(struct soap *soap, const char *tag, struct ns1__runDollopResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runDollopResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runDollopResponse, sizeof(struct ns1__runDollopResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runDollopResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runDollopResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runDollopResponse, 0, sizeof(struct ns1__runDollopResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runPenny(struct soap *soap, struct ns1__runPenny *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runPenny(struct soap *soap, const struct ns1__runPenny *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runPenny(struct soap *soap, const struct ns1__runPenny *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runPenny);
	if (soap_out_ns1__runPenny(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runPenny(struct soap *soap, const char *tag, int id, const struct ns1__runPenny *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runPenny), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runPenny * SOAP_FMAC4 soap_get_ns1__runPenny(struct soap *soap, struct ns1__runPenny *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runPenny(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runPenny * SOAP_FMAC4 soap_in_ns1__runPenny(struct soap *soap, const char *tag, struct ns1__runPenny *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runPenny *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runPenny, sizeof(struct ns1__runPenny), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runPenny(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runPenny *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runPenny, 0, sizeof(struct ns1__runPenny), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runPennyResponse(struct soap *soap, struct ns1__runPennyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runPennyResponse(struct soap *soap, const struct ns1__runPennyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runPennyResponse(struct soap *soap, const struct ns1__runPennyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runPennyResponse);
	if (soap_out_ns1__runPennyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runPennyResponse(struct soap *soap, const char *tag, int id, const struct ns1__runPennyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runPennyResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runPennyResponse * SOAP_FMAC4 soap_get_ns1__runPennyResponse(struct soap *soap, struct ns1__runPennyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runPennyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runPennyResponse * SOAP_FMAC4 soap_in_ns1__runPennyResponse(struct soap *soap, const char *tag, struct ns1__runPennyResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runPennyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runPennyResponse, sizeof(struct ns1__runPennyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runPennyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runPennyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runPennyResponse, 0, sizeof(struct ns1__runPennyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runMix(struct soap *soap, struct ns1__runMix *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runMix(struct soap *soap, const struct ns1__runMix *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runMix(struct soap *soap, const struct ns1__runMix *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runMix);
	if (soap_out_ns1__runMix(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runMix(struct soap *soap, const char *tag, int id, const struct ns1__runMix *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runMix), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runMix * SOAP_FMAC4 soap_get_ns1__runMix(struct soap *soap, struct ns1__runMix *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runMix(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runMix * SOAP_FMAC4 soap_in_ns1__runMix(struct soap *soap, const char *tag, struct ns1__runMix *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runMix *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runMix, sizeof(struct ns1__runMix), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runMix(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runMix *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runMix, 0, sizeof(struct ns1__runMix), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runMixResponse(struct soap *soap, struct ns1__runMixResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runMixResponse(struct soap *soap, const struct ns1__runMixResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runMixResponse(struct soap *soap, const struct ns1__runMixResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runMixResponse);
	if (soap_out_ns1__runMixResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runMixResponse(struct soap *soap, const char *tag, int id, const struct ns1__runMixResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runMixResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runMixResponse * SOAP_FMAC4 soap_get_ns1__runMixResponse(struct soap *soap, struct ns1__runMixResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runMixResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runMixResponse * SOAP_FMAC4 soap_in_ns1__runMixResponse(struct soap *soap, const char *tag, struct ns1__runMixResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runMixResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runMixResponse, sizeof(struct ns1__runMixResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runMixResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runMixResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runMixResponse, 0, sizeof(struct ns1__runMixResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runContml(struct soap *soap, struct ns1__runContml *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runContml(struct soap *soap, const struct ns1__runContml *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runContml(struct soap *soap, const struct ns1__runContml *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runContml);
	if (soap_out_ns1__runContml(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runContml(struct soap *soap, const char *tag, int id, const struct ns1__runContml *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runContml), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runContml * SOAP_FMAC4 soap_get_ns1__runContml(struct soap *soap, struct ns1__runContml *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runContml(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runContml * SOAP_FMAC4 soap_in_ns1__runContml(struct soap *soap, const char *tag, struct ns1__runContml *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runContml *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runContml, sizeof(struct ns1__runContml), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runContml(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runContml *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runContml, 0, sizeof(struct ns1__runContml), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runContmlResponse(struct soap *soap, struct ns1__runContmlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runContmlResponse(struct soap *soap, const struct ns1__runContmlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runContmlResponse(struct soap *soap, const struct ns1__runContmlResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runContmlResponse);
	if (soap_out_ns1__runContmlResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runContmlResponse(struct soap *soap, const char *tag, int id, const struct ns1__runContmlResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runContmlResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runContmlResponse * SOAP_FMAC4 soap_get_ns1__runContmlResponse(struct soap *soap, struct ns1__runContmlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runContmlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runContmlResponse * SOAP_FMAC4 soap_in_ns1__runContmlResponse(struct soap *soap, const char *tag, struct ns1__runContmlResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runContmlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runContmlResponse, sizeof(struct ns1__runContmlResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runContmlResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runContmlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runContmlResponse, 0, sizeof(struct ns1__runContmlResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runNeighbor(struct soap *soap, struct ns1__runNeighbor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runNeighbor(struct soap *soap, const struct ns1__runNeighbor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runNeighbor(struct soap *soap, const struct ns1__runNeighbor *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runNeighbor);
	if (soap_out_ns1__runNeighbor(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runNeighbor(struct soap *soap, const char *tag, int id, const struct ns1__runNeighbor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runNeighbor), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runNeighbor * SOAP_FMAC4 soap_get_ns1__runNeighbor(struct soap *soap, struct ns1__runNeighbor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runNeighbor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runNeighbor * SOAP_FMAC4 soap_in_ns1__runNeighbor(struct soap *soap, const char *tag, struct ns1__runNeighbor *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runNeighbor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runNeighbor, sizeof(struct ns1__runNeighbor), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runNeighbor(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runNeighbor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runNeighbor, 0, sizeof(struct ns1__runNeighbor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runNeighborResponse(struct soap *soap, struct ns1__runNeighborResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runNeighborResponse(struct soap *soap, const struct ns1__runNeighborResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runNeighborResponse(struct soap *soap, const struct ns1__runNeighborResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runNeighborResponse);
	if (soap_out_ns1__runNeighborResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runNeighborResponse(struct soap *soap, const char *tag, int id, const struct ns1__runNeighborResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runNeighborResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runNeighborResponse * SOAP_FMAC4 soap_get_ns1__runNeighborResponse(struct soap *soap, struct ns1__runNeighborResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runNeighborResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runNeighborResponse * SOAP_FMAC4 soap_in_ns1__runNeighborResponse(struct soap *soap, const char *tag, struct ns1__runNeighborResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runNeighborResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runNeighborResponse, sizeof(struct ns1__runNeighborResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runNeighborResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runNeighborResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runNeighborResponse, 0, sizeof(struct ns1__runNeighborResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runKitsch(struct soap *soap, struct ns1__runKitsch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runKitsch(struct soap *soap, const struct ns1__runKitsch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runKitsch(struct soap *soap, const struct ns1__runKitsch *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runKitsch);
	if (soap_out_ns1__runKitsch(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runKitsch(struct soap *soap, const char *tag, int id, const struct ns1__runKitsch *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runKitsch), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runKitsch * SOAP_FMAC4 soap_get_ns1__runKitsch(struct soap *soap, struct ns1__runKitsch *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runKitsch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runKitsch * SOAP_FMAC4 soap_in_ns1__runKitsch(struct soap *soap, const char *tag, struct ns1__runKitsch *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runKitsch *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runKitsch, sizeof(struct ns1__runKitsch), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runKitsch(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runKitsch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runKitsch, 0, sizeof(struct ns1__runKitsch), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runKitschResponse(struct soap *soap, struct ns1__runKitschResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runKitschResponse(struct soap *soap, const struct ns1__runKitschResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runKitschResponse(struct soap *soap, const struct ns1__runKitschResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runKitschResponse);
	if (soap_out_ns1__runKitschResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runKitschResponse(struct soap *soap, const char *tag, int id, const struct ns1__runKitschResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runKitschResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runKitschResponse * SOAP_FMAC4 soap_get_ns1__runKitschResponse(struct soap *soap, struct ns1__runKitschResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runKitschResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runKitschResponse * SOAP_FMAC4 soap_in_ns1__runKitschResponse(struct soap *soap, const char *tag, struct ns1__runKitschResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runKitschResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runKitschResponse, sizeof(struct ns1__runKitschResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runKitschResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runKitschResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runKitschResponse, 0, sizeof(struct ns1__runKitschResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runFitch(struct soap *soap, struct ns1__runFitch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runFitch(struct soap *soap, const struct ns1__runFitch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runFitch(struct soap *soap, const struct ns1__runFitch *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runFitch);
	if (soap_out_ns1__runFitch(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runFitch(struct soap *soap, const char *tag, int id, const struct ns1__runFitch *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runFitch), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runFitch * SOAP_FMAC4 soap_get_ns1__runFitch(struct soap *soap, struct ns1__runFitch *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runFitch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runFitch * SOAP_FMAC4 soap_in_ns1__runFitch(struct soap *soap, const char *tag, struct ns1__runFitch *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runFitch *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runFitch, sizeof(struct ns1__runFitch), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runFitch(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runFitch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runFitch, 0, sizeof(struct ns1__runFitch), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runFitchResponse(struct soap *soap, struct ns1__runFitchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runFitchResponse(struct soap *soap, const struct ns1__runFitchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runFitchResponse(struct soap *soap, const struct ns1__runFitchResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runFitchResponse);
	if (soap_out_ns1__runFitchResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runFitchResponse(struct soap *soap, const char *tag, int id, const struct ns1__runFitchResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runFitchResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runFitchResponse * SOAP_FMAC4 soap_get_ns1__runFitchResponse(struct soap *soap, struct ns1__runFitchResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runFitchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runFitchResponse * SOAP_FMAC4 soap_in_ns1__runFitchResponse(struct soap *soap, const char *tag, struct ns1__runFitchResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runFitchResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runFitchResponse, sizeof(struct ns1__runFitchResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runFitchResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runFitchResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runFitchResponse, 0, sizeof(struct ns1__runFitchResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runClique(struct soap *soap, struct ns1__runClique *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runClique(struct soap *soap, const struct ns1__runClique *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runClique(struct soap *soap, const struct ns1__runClique *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runClique);
	if (soap_out_ns1__runClique(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runClique(struct soap *soap, const char *tag, int id, const struct ns1__runClique *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runClique), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runClique * SOAP_FMAC4 soap_get_ns1__runClique(struct soap *soap, struct ns1__runClique *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runClique(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runClique * SOAP_FMAC4 soap_in_ns1__runClique(struct soap *soap, const char *tag, struct ns1__runClique *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runClique *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runClique, sizeof(struct ns1__runClique), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runClique(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runClique *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runClique, 0, sizeof(struct ns1__runClique), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runCliqueResponse(struct soap *soap, struct ns1__runCliqueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runCliqueResponse(struct soap *soap, const struct ns1__runCliqueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runCliqueResponse(struct soap *soap, const struct ns1__runCliqueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runCliqueResponse);
	if (soap_out_ns1__runCliqueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runCliqueResponse(struct soap *soap, const char *tag, int id, const struct ns1__runCliqueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runCliqueResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runCliqueResponse * SOAP_FMAC4 soap_get_ns1__runCliqueResponse(struct soap *soap, struct ns1__runCliqueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runCliqueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runCliqueResponse * SOAP_FMAC4 soap_in_ns1__runCliqueResponse(struct soap *soap, const char *tag, struct ns1__runCliqueResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runCliqueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runCliqueResponse, sizeof(struct ns1__runCliqueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runCliqueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runCliqueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runCliqueResponse, 0, sizeof(struct ns1__runCliqueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runRestml(struct soap *soap, struct ns1__runRestml *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runRestml(struct soap *soap, const struct ns1__runRestml *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runRestml(struct soap *soap, const struct ns1__runRestml *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runRestml);
	if (soap_out_ns1__runRestml(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runRestml(struct soap *soap, const char *tag, int id, const struct ns1__runRestml *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runRestml), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runRestml * SOAP_FMAC4 soap_get_ns1__runRestml(struct soap *soap, struct ns1__runRestml *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runRestml(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runRestml * SOAP_FMAC4 soap_in_ns1__runRestml(struct soap *soap, const char *tag, struct ns1__runRestml *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runRestml *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runRestml, sizeof(struct ns1__runRestml), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runRestml(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runRestml *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runRestml, 0, sizeof(struct ns1__runRestml), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runRestmlResponse(struct soap *soap, struct ns1__runRestmlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runRestmlResponse(struct soap *soap, const struct ns1__runRestmlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runRestmlResponse(struct soap *soap, const struct ns1__runRestmlResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runRestmlResponse);
	if (soap_out_ns1__runRestmlResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runRestmlResponse(struct soap *soap, const char *tag, int id, const struct ns1__runRestmlResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runRestmlResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runRestmlResponse * SOAP_FMAC4 soap_get_ns1__runRestmlResponse(struct soap *soap, struct ns1__runRestmlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runRestmlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runRestmlResponse * SOAP_FMAC4 soap_in_ns1__runRestmlResponse(struct soap *soap, const char *tag, struct ns1__runRestmlResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runRestmlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runRestmlResponse, sizeof(struct ns1__runRestmlResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runRestmlResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runRestmlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runRestmlResponse, 0, sizeof(struct ns1__runRestmlResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runSeqboot(struct soap *soap, struct ns1__runSeqboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runSeqboot(struct soap *soap, const struct ns1__runSeqboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runSeqboot(struct soap *soap, const struct ns1__runSeqboot *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runSeqboot);
	if (soap_out_ns1__runSeqboot(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runSeqboot(struct soap *soap, const char *tag, int id, const struct ns1__runSeqboot *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runSeqboot), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runSeqboot * SOAP_FMAC4 soap_get_ns1__runSeqboot(struct soap *soap, struct ns1__runSeqboot *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runSeqboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runSeqboot * SOAP_FMAC4 soap_in_ns1__runSeqboot(struct soap *soap, const char *tag, struct ns1__runSeqboot *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runSeqboot *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runSeqboot, sizeof(struct ns1__runSeqboot), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runSeqboot(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runSeqboot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runSeqboot, 0, sizeof(struct ns1__runSeqboot), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runSeqbootResponse(struct soap *soap, struct ns1__runSeqbootResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runSeqbootResponse(struct soap *soap, const struct ns1__runSeqbootResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runSeqbootResponse(struct soap *soap, const struct ns1__runSeqbootResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runSeqbootResponse);
	if (soap_out_ns1__runSeqbootResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runSeqbootResponse(struct soap *soap, const char *tag, int id, const struct ns1__runSeqbootResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runSeqbootResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runSeqbootResponse * SOAP_FMAC4 soap_get_ns1__runSeqbootResponse(struct soap *soap, struct ns1__runSeqbootResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runSeqbootResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runSeqbootResponse * SOAP_FMAC4 soap_in_ns1__runSeqbootResponse(struct soap *soap, const char *tag, struct ns1__runSeqbootResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runSeqbootResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runSeqbootResponse, sizeof(struct ns1__runSeqbootResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runSeqbootResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runSeqbootResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runSeqbootResponse, 0, sizeof(struct ns1__runSeqbootResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runGendist(struct soap *soap, struct ns1__runGendist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runGendist(struct soap *soap, const struct ns1__runGendist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runGendist(struct soap *soap, const struct ns1__runGendist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runGendist);
	if (soap_out_ns1__runGendist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runGendist(struct soap *soap, const char *tag, int id, const struct ns1__runGendist *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runGendist), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runGendist * SOAP_FMAC4 soap_get_ns1__runGendist(struct soap *soap, struct ns1__runGendist *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runGendist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runGendist * SOAP_FMAC4 soap_in_ns1__runGendist(struct soap *soap, const char *tag, struct ns1__runGendist *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runGendist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runGendist, sizeof(struct ns1__runGendist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runGendist(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runGendist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runGendist, 0, sizeof(struct ns1__runGendist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runGendistResponse(struct soap *soap, struct ns1__runGendistResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runGendistResponse(struct soap *soap, const struct ns1__runGendistResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runGendistResponse(struct soap *soap, const struct ns1__runGendistResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runGendistResponse);
	if (soap_out_ns1__runGendistResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runGendistResponse(struct soap *soap, const char *tag, int id, const struct ns1__runGendistResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runGendistResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runGendistResponse * SOAP_FMAC4 soap_get_ns1__runGendistResponse(struct soap *soap, struct ns1__runGendistResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runGendistResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runGendistResponse * SOAP_FMAC4 soap_in_ns1__runGendistResponse(struct soap *soap, const char *tag, struct ns1__runGendistResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runGendistResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runGendistResponse, sizeof(struct ns1__runGendistResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runGendistResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runGendistResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runGendistResponse, 0, sizeof(struct ns1__runGendistResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runDnadist(struct soap *soap, struct ns1__runDnadist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runDnadist(struct soap *soap, const struct ns1__runDnadist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runDnadist(struct soap *soap, const struct ns1__runDnadist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runDnadist);
	if (soap_out_ns1__runDnadist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runDnadist(struct soap *soap, const char *tag, int id, const struct ns1__runDnadist *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runDnadist), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runDnadist * SOAP_FMAC4 soap_get_ns1__runDnadist(struct soap *soap, struct ns1__runDnadist *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runDnadist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runDnadist * SOAP_FMAC4 soap_in_ns1__runDnadist(struct soap *soap, const char *tag, struct ns1__runDnadist *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runDnadist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runDnadist, sizeof(struct ns1__runDnadist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runDnadist(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runDnadist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runDnadist, 0, sizeof(struct ns1__runDnadist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runDnadistResponse(struct soap *soap, struct ns1__runDnadistResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runDnadistResponse(struct soap *soap, const struct ns1__runDnadistResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runDnadistResponse(struct soap *soap, const struct ns1__runDnadistResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runDnadistResponse);
	if (soap_out_ns1__runDnadistResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runDnadistResponse(struct soap *soap, const char *tag, int id, const struct ns1__runDnadistResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runDnadistResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runDnadistResponse * SOAP_FMAC4 soap_get_ns1__runDnadistResponse(struct soap *soap, struct ns1__runDnadistResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runDnadistResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runDnadistResponse * SOAP_FMAC4 soap_in_ns1__runDnadistResponse(struct soap *soap, const char *tag, struct ns1__runDnadistResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runDnadistResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runDnadistResponse, sizeof(struct ns1__runDnadistResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runDnadistResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runDnadistResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runDnadistResponse, 0, sizeof(struct ns1__runDnadistResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runDnamlk(struct soap *soap, struct ns1__runDnamlk *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runDnamlk(struct soap *soap, const struct ns1__runDnamlk *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runDnamlk(struct soap *soap, const struct ns1__runDnamlk *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runDnamlk);
	if (soap_out_ns1__runDnamlk(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runDnamlk(struct soap *soap, const char *tag, int id, const struct ns1__runDnamlk *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runDnamlk), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runDnamlk * SOAP_FMAC4 soap_get_ns1__runDnamlk(struct soap *soap, struct ns1__runDnamlk *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runDnamlk(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runDnamlk * SOAP_FMAC4 soap_in_ns1__runDnamlk(struct soap *soap, const char *tag, struct ns1__runDnamlk *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runDnamlk *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runDnamlk, sizeof(struct ns1__runDnamlk), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runDnamlk(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runDnamlk *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runDnamlk, 0, sizeof(struct ns1__runDnamlk), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runDnamlkResponse(struct soap *soap, struct ns1__runDnamlkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runDnamlkResponse(struct soap *soap, const struct ns1__runDnamlkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runDnamlkResponse(struct soap *soap, const struct ns1__runDnamlkResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runDnamlkResponse);
	if (soap_out_ns1__runDnamlkResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runDnamlkResponse(struct soap *soap, const char *tag, int id, const struct ns1__runDnamlkResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runDnamlkResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runDnamlkResponse * SOAP_FMAC4 soap_get_ns1__runDnamlkResponse(struct soap *soap, struct ns1__runDnamlkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runDnamlkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runDnamlkResponse * SOAP_FMAC4 soap_in_ns1__runDnamlkResponse(struct soap *soap, const char *tag, struct ns1__runDnamlkResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runDnamlkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runDnamlkResponse, sizeof(struct ns1__runDnamlkResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runDnamlkResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runDnamlkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runDnamlkResponse, 0, sizeof(struct ns1__runDnamlkResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runDnaml(struct soap *soap, struct ns1__runDnaml *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runDnaml(struct soap *soap, const struct ns1__runDnaml *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runDnaml(struct soap *soap, const struct ns1__runDnaml *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runDnaml);
	if (soap_out_ns1__runDnaml(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runDnaml(struct soap *soap, const char *tag, int id, const struct ns1__runDnaml *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runDnaml), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runDnaml * SOAP_FMAC4 soap_get_ns1__runDnaml(struct soap *soap, struct ns1__runDnaml *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runDnaml(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runDnaml * SOAP_FMAC4 soap_in_ns1__runDnaml(struct soap *soap, const char *tag, struct ns1__runDnaml *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runDnaml *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runDnaml, sizeof(struct ns1__runDnaml), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runDnaml(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runDnaml *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runDnaml, 0, sizeof(struct ns1__runDnaml), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runDnamlResponse(struct soap *soap, struct ns1__runDnamlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runDnamlResponse(struct soap *soap, const struct ns1__runDnamlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runDnamlResponse(struct soap *soap, const struct ns1__runDnamlResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runDnamlResponse);
	if (soap_out_ns1__runDnamlResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runDnamlResponse(struct soap *soap, const char *tag, int id, const struct ns1__runDnamlResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runDnamlResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runDnamlResponse * SOAP_FMAC4 soap_get_ns1__runDnamlResponse(struct soap *soap, struct ns1__runDnamlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runDnamlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runDnamlResponse * SOAP_FMAC4 soap_in_ns1__runDnamlResponse(struct soap *soap, const char *tag, struct ns1__runDnamlResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runDnamlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runDnamlResponse, sizeof(struct ns1__runDnamlResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runDnamlResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runDnamlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runDnamlResponse, 0, sizeof(struct ns1__runDnamlResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runDnainvar(struct soap *soap, struct ns1__runDnainvar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runDnainvar(struct soap *soap, const struct ns1__runDnainvar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runDnainvar(struct soap *soap, const struct ns1__runDnainvar *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runDnainvar);
	if (soap_out_ns1__runDnainvar(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runDnainvar(struct soap *soap, const char *tag, int id, const struct ns1__runDnainvar *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runDnainvar), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runDnainvar * SOAP_FMAC4 soap_get_ns1__runDnainvar(struct soap *soap, struct ns1__runDnainvar *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runDnainvar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runDnainvar * SOAP_FMAC4 soap_in_ns1__runDnainvar(struct soap *soap, const char *tag, struct ns1__runDnainvar *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runDnainvar *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runDnainvar, sizeof(struct ns1__runDnainvar), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runDnainvar(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runDnainvar *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runDnainvar, 0, sizeof(struct ns1__runDnainvar), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runDnainvarResponse(struct soap *soap, struct ns1__runDnainvarResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runDnainvarResponse(struct soap *soap, const struct ns1__runDnainvarResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runDnainvarResponse(struct soap *soap, const struct ns1__runDnainvarResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runDnainvarResponse);
	if (soap_out_ns1__runDnainvarResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runDnainvarResponse(struct soap *soap, const char *tag, int id, const struct ns1__runDnainvarResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runDnainvarResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runDnainvarResponse * SOAP_FMAC4 soap_get_ns1__runDnainvarResponse(struct soap *soap, struct ns1__runDnainvarResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runDnainvarResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runDnainvarResponse * SOAP_FMAC4 soap_in_ns1__runDnainvarResponse(struct soap *soap, const char *tag, struct ns1__runDnainvarResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runDnainvarResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runDnainvarResponse, sizeof(struct ns1__runDnainvarResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runDnainvarResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runDnainvarResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runDnainvarResponse, 0, sizeof(struct ns1__runDnainvarResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runDnacomp(struct soap *soap, struct ns1__runDnacomp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runDnacomp(struct soap *soap, const struct ns1__runDnacomp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runDnacomp(struct soap *soap, const struct ns1__runDnacomp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runDnacomp);
	if (soap_out_ns1__runDnacomp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runDnacomp(struct soap *soap, const char *tag, int id, const struct ns1__runDnacomp *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runDnacomp), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runDnacomp * SOAP_FMAC4 soap_get_ns1__runDnacomp(struct soap *soap, struct ns1__runDnacomp *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runDnacomp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runDnacomp * SOAP_FMAC4 soap_in_ns1__runDnacomp(struct soap *soap, const char *tag, struct ns1__runDnacomp *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runDnacomp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runDnacomp, sizeof(struct ns1__runDnacomp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runDnacomp(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runDnacomp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runDnacomp, 0, sizeof(struct ns1__runDnacomp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runDnacompResponse(struct soap *soap, struct ns1__runDnacompResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runDnacompResponse(struct soap *soap, const struct ns1__runDnacompResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runDnacompResponse(struct soap *soap, const struct ns1__runDnacompResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runDnacompResponse);
	if (soap_out_ns1__runDnacompResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runDnacompResponse(struct soap *soap, const char *tag, int id, const struct ns1__runDnacompResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runDnacompResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runDnacompResponse * SOAP_FMAC4 soap_get_ns1__runDnacompResponse(struct soap *soap, struct ns1__runDnacompResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runDnacompResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runDnacompResponse * SOAP_FMAC4 soap_in_ns1__runDnacompResponse(struct soap *soap, const char *tag, struct ns1__runDnacompResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runDnacompResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runDnacompResponse, sizeof(struct ns1__runDnacompResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runDnacompResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runDnacompResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runDnacompResponse, 0, sizeof(struct ns1__runDnacompResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runDnapenny(struct soap *soap, struct ns1__runDnapenny *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runDnapenny(struct soap *soap, const struct ns1__runDnapenny *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runDnapenny(struct soap *soap, const struct ns1__runDnapenny *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runDnapenny);
	if (soap_out_ns1__runDnapenny(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runDnapenny(struct soap *soap, const char *tag, int id, const struct ns1__runDnapenny *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runDnapenny), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runDnapenny * SOAP_FMAC4 soap_get_ns1__runDnapenny(struct soap *soap, struct ns1__runDnapenny *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runDnapenny(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runDnapenny * SOAP_FMAC4 soap_in_ns1__runDnapenny(struct soap *soap, const char *tag, struct ns1__runDnapenny *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runDnapenny *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runDnapenny, sizeof(struct ns1__runDnapenny), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runDnapenny(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runDnapenny *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runDnapenny, 0, sizeof(struct ns1__runDnapenny), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runDnapennyResponse(struct soap *soap, struct ns1__runDnapennyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runDnapennyResponse(struct soap *soap, const struct ns1__runDnapennyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runDnapennyResponse(struct soap *soap, const struct ns1__runDnapennyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runDnapennyResponse);
	if (soap_out_ns1__runDnapennyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runDnapennyResponse(struct soap *soap, const char *tag, int id, const struct ns1__runDnapennyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runDnapennyResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runDnapennyResponse * SOAP_FMAC4 soap_get_ns1__runDnapennyResponse(struct soap *soap, struct ns1__runDnapennyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runDnapennyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runDnapennyResponse * SOAP_FMAC4 soap_in_ns1__runDnapennyResponse(struct soap *soap, const char *tag, struct ns1__runDnapennyResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runDnapennyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runDnapennyResponse, sizeof(struct ns1__runDnapennyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runDnapennyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runDnapennyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runDnapennyResponse, 0, sizeof(struct ns1__runDnapennyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runDnapars(struct soap *soap, struct ns1__runDnapars *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runDnapars(struct soap *soap, const struct ns1__runDnapars *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runDnapars(struct soap *soap, const struct ns1__runDnapars *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runDnapars);
	if (soap_out_ns1__runDnapars(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runDnapars(struct soap *soap, const char *tag, int id, const struct ns1__runDnapars *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runDnapars), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runDnapars * SOAP_FMAC4 soap_get_ns1__runDnapars(struct soap *soap, struct ns1__runDnapars *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runDnapars(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runDnapars * SOAP_FMAC4 soap_in_ns1__runDnapars(struct soap *soap, const char *tag, struct ns1__runDnapars *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runDnapars *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runDnapars, sizeof(struct ns1__runDnapars), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runDnapars(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runDnapars *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runDnapars, 0, sizeof(struct ns1__runDnapars), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runDnaparsResponse(struct soap *soap, struct ns1__runDnaparsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runDnaparsResponse(struct soap *soap, const struct ns1__runDnaparsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runDnaparsResponse(struct soap *soap, const struct ns1__runDnaparsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runDnaparsResponse);
	if (soap_out_ns1__runDnaparsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runDnaparsResponse(struct soap *soap, const char *tag, int id, const struct ns1__runDnaparsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runDnaparsResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runDnaparsResponse * SOAP_FMAC4 soap_get_ns1__runDnaparsResponse(struct soap *soap, struct ns1__runDnaparsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runDnaparsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runDnaparsResponse * SOAP_FMAC4 soap_in_ns1__runDnaparsResponse(struct soap *soap, const char *tag, struct ns1__runDnaparsResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runDnaparsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runDnaparsResponse, sizeof(struct ns1__runDnaparsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runDnaparsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runDnaparsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runDnaparsResponse, 0, sizeof(struct ns1__runDnaparsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runProtdist(struct soap *soap, struct ns1__runProtdist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runProtdist(struct soap *soap, const struct ns1__runProtdist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runProtdist(struct soap *soap, const struct ns1__runProtdist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runProtdist);
	if (soap_out_ns1__runProtdist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runProtdist(struct soap *soap, const char *tag, int id, const struct ns1__runProtdist *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runProtdist), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runProtdist * SOAP_FMAC4 soap_get_ns1__runProtdist(struct soap *soap, struct ns1__runProtdist *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runProtdist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runProtdist * SOAP_FMAC4 soap_in_ns1__runProtdist(struct soap *soap, const char *tag, struct ns1__runProtdist *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runProtdist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runProtdist, sizeof(struct ns1__runProtdist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runProtdist(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runProtdist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runProtdist, 0, sizeof(struct ns1__runProtdist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runProtdistResponse(struct soap *soap, struct ns1__runProtdistResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runProtdistResponse(struct soap *soap, const struct ns1__runProtdistResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runProtdistResponse(struct soap *soap, const struct ns1__runProtdistResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runProtdistResponse);
	if (soap_out_ns1__runProtdistResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runProtdistResponse(struct soap *soap, const char *tag, int id, const struct ns1__runProtdistResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runProtdistResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runProtdistResponse * SOAP_FMAC4 soap_get_ns1__runProtdistResponse(struct soap *soap, struct ns1__runProtdistResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runProtdistResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runProtdistResponse * SOAP_FMAC4 soap_in_ns1__runProtdistResponse(struct soap *soap, const char *tag, struct ns1__runProtdistResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runProtdistResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runProtdistResponse, sizeof(struct ns1__runProtdistResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runProtdistResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runProtdistResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runProtdistResponse, 0, sizeof(struct ns1__runProtdistResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runProtpars(struct soap *soap, struct ns1__runProtpars *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runProtpars(struct soap *soap, const struct ns1__runProtpars *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runProtpars(struct soap *soap, const struct ns1__runProtpars *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runProtpars);
	if (soap_out_ns1__runProtpars(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runProtpars(struct soap *soap, const char *tag, int id, const struct ns1__runProtpars *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runProtpars), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runProtpars * SOAP_FMAC4 soap_get_ns1__runProtpars(struct soap *soap, struct ns1__runProtpars *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runProtpars(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runProtpars * SOAP_FMAC4 soap_in_ns1__runProtpars(struct soap *soap, const char *tag, struct ns1__runProtpars *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runProtpars *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runProtpars, sizeof(struct ns1__runProtpars), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runProtpars(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runProtpars *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runProtpars, 0, sizeof(struct ns1__runProtpars), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runProtparsResponse(struct soap *soap, struct ns1__runProtparsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runProtparsResponse(struct soap *soap, const struct ns1__runProtparsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runProtparsResponse(struct soap *soap, const struct ns1__runProtparsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runProtparsResponse);
	if (soap_out_ns1__runProtparsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runProtparsResponse(struct soap *soap, const char *tag, int id, const struct ns1__runProtparsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runProtparsResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runProtparsResponse * SOAP_FMAC4 soap_get_ns1__runProtparsResponse(struct soap *soap, struct ns1__runProtparsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runProtparsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runProtparsResponse * SOAP_FMAC4 soap_in_ns1__runProtparsResponse(struct soap *soap, const char *tag, struct ns1__runProtparsResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runProtparsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runProtparsResponse, sizeof(struct ns1__runProtparsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runProtparsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runProtparsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runProtparsResponse, 0, sizeof(struct ns1__runProtparsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runPhobius(struct soap *soap, struct ns1__runPhobius *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
	a->_params = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runPhobius(struct soap *soap, const struct ns1__runPhobius *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
	soap_serialize_PointerTons1__phobiusInputParams(soap, &a->_params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runPhobius(struct soap *soap, const struct ns1__runPhobius *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runPhobius);
	if (soap_out_ns1__runPhobius(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runPhobius(struct soap *soap, const char *tag, int id, const struct ns1__runPhobius *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runPhobius), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_PointerTons1__phobiusInputParams(soap, "params", -1, &a->_params, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runPhobius * SOAP_FMAC4 soap_get_ns1__runPhobius(struct soap *soap, struct ns1__runPhobius *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runPhobius(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runPhobius * SOAP_FMAC4 soap_in_ns1__runPhobius(struct soap *soap, const char *tag, struct ns1__runPhobius *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runPhobius *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runPhobius, sizeof(struct ns1__runPhobius), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runPhobius(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__phobiusInputParams(soap, NULL, &a->_params, "ns1:phobiusInputParams"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runPhobius *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runPhobius, 0, sizeof(struct ns1__runPhobius), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runPhobiusResponse(struct soap *soap, struct ns1__runPhobiusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runPhobiusResponse(struct soap *soap, const struct ns1__runPhobiusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runPhobiusResponse(struct soap *soap, const struct ns1__runPhobiusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runPhobiusResponse);
	if (soap_out_ns1__runPhobiusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runPhobiusResponse(struct soap *soap, const char *tag, int id, const struct ns1__runPhobiusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runPhobiusResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runPhobiusResponse * SOAP_FMAC4 soap_get_ns1__runPhobiusResponse(struct soap *soap, struct ns1__runPhobiusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runPhobiusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runPhobiusResponse * SOAP_FMAC4 soap_in_ns1__runPhobiusResponse(struct soap *soap, const char *tag, struct ns1__runPhobiusResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runPhobiusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runPhobiusResponse, sizeof(struct ns1__runPhobiusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runPhobiusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runPhobiusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runPhobiusResponse, 0, sizeof(struct ns1__runPhobiusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runMuscle(struct soap *soap, struct ns1__runMuscle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
	a->_params = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runMuscle(struct soap *soap, const struct ns1__runMuscle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
	soap_serialize_PointerTons1__muscleInputParams(soap, &a->_params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runMuscle(struct soap *soap, const struct ns1__runMuscle *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runMuscle);
	if (soap_out_ns1__runMuscle(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runMuscle(struct soap *soap, const char *tag, int id, const struct ns1__runMuscle *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runMuscle), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_PointerTons1__muscleInputParams(soap, "params", -1, &a->_params, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runMuscle * SOAP_FMAC4 soap_get_ns1__runMuscle(struct soap *soap, struct ns1__runMuscle *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runMuscle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runMuscle * SOAP_FMAC4 soap_in_ns1__runMuscle(struct soap *soap, const char *tag, struct ns1__runMuscle *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runMuscle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runMuscle, sizeof(struct ns1__runMuscle), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runMuscle(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__muscleInputParams(soap, NULL, &a->_params, "ns1:muscleInputParams"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runMuscle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runMuscle, 0, sizeof(struct ns1__runMuscle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runMuscleResponse(struct soap *soap, struct ns1__runMuscleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runMuscleResponse(struct soap *soap, const struct ns1__runMuscleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runMuscleResponse(struct soap *soap, const struct ns1__runMuscleResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runMuscleResponse);
	if (soap_out_ns1__runMuscleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runMuscleResponse(struct soap *soap, const char *tag, int id, const struct ns1__runMuscleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runMuscleResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runMuscleResponse * SOAP_FMAC4 soap_get_ns1__runMuscleResponse(struct soap *soap, struct ns1__runMuscleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runMuscleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runMuscleResponse * SOAP_FMAC4 soap_in_ns1__runMuscleResponse(struct soap *soap, const char *tag, struct ns1__runMuscleResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runMuscleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runMuscleResponse, sizeof(struct ns1__runMuscleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runMuscleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runMuscleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runMuscleResponse, 0, sizeof(struct ns1__runMuscleResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runMafft(struct soap *soap, struct ns1__runMafft *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
	a->_params = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runMafft(struct soap *soap, const struct ns1__runMafft *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
	soap_serialize_PointerTons1__mafftInputParams(soap, &a->_params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runMafft(struct soap *soap, const struct ns1__runMafft *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runMafft);
	if (soap_out_ns1__runMafft(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runMafft(struct soap *soap, const char *tag, int id, const struct ns1__runMafft *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runMafft), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_PointerTons1__mafftInputParams(soap, "params", -1, &a->_params, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runMafft * SOAP_FMAC4 soap_get_ns1__runMafft(struct soap *soap, struct ns1__runMafft *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runMafft(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runMafft * SOAP_FMAC4 soap_in_ns1__runMafft(struct soap *soap, const char *tag, struct ns1__runMafft *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runMafft *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runMafft, sizeof(struct ns1__runMafft), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runMafft(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__mafftInputParams(soap, NULL, &a->_params, "ns1:mafftInputParams"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runMafft *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runMafft, 0, sizeof(struct ns1__runMafft), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runMafftResponse(struct soap *soap, struct ns1__runMafftResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runMafftResponse(struct soap *soap, const struct ns1__runMafftResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runMafftResponse(struct soap *soap, const struct ns1__runMafftResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runMafftResponse);
	if (soap_out_ns1__runMafftResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runMafftResponse(struct soap *soap, const char *tag, int id, const struct ns1__runMafftResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runMafftResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runMafftResponse * SOAP_FMAC4 soap_get_ns1__runMafftResponse(struct soap *soap, struct ns1__runMafftResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runMafftResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runMafftResponse * SOAP_FMAC4 soap_in_ns1__runMafftResponse(struct soap *soap, const char *tag, struct ns1__runMafftResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runMafftResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runMafftResponse, sizeof(struct ns1__runMafftResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runMafftResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runMafftResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runMafftResponse, 0, sizeof(struct ns1__runMafftResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runKalign(struct soap *soap, struct ns1__runKalign *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
	a->_params = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runKalign(struct soap *soap, const struct ns1__runKalign *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
	soap_serialize_PointerTons1__kalignInputParams(soap, &a->_params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runKalign(struct soap *soap, const struct ns1__runKalign *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runKalign);
	if (soap_out_ns1__runKalign(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runKalign(struct soap *soap, const char *tag, int id, const struct ns1__runKalign *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runKalign), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_PointerTons1__kalignInputParams(soap, "params", -1, &a->_params, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runKalign * SOAP_FMAC4 soap_get_ns1__runKalign(struct soap *soap, struct ns1__runKalign *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runKalign(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runKalign * SOAP_FMAC4 soap_in_ns1__runKalign(struct soap *soap, const char *tag, struct ns1__runKalign *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runKalign *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runKalign, sizeof(struct ns1__runKalign), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runKalign(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__kalignInputParams(soap, NULL, &a->_params, "ns1:kalignInputParams"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runKalign *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runKalign, 0, sizeof(struct ns1__runKalign), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runKalignResponse(struct soap *soap, struct ns1__runKalignResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runKalignResponse(struct soap *soap, const struct ns1__runKalignResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runKalignResponse(struct soap *soap, const struct ns1__runKalignResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runKalignResponse);
	if (soap_out_ns1__runKalignResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runKalignResponse(struct soap *soap, const char *tag, int id, const struct ns1__runKalignResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runKalignResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runKalignResponse * SOAP_FMAC4 soap_get_ns1__runKalignResponse(struct soap *soap, struct ns1__runKalignResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runKalignResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runKalignResponse * SOAP_FMAC4 soap_in_ns1__runKalignResponse(struct soap *soap, const char *tag, struct ns1__runKalignResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runKalignResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runKalignResponse, sizeof(struct ns1__runKalignResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runKalignResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runKalignResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runKalignResponse, 0, sizeof(struct ns1__runKalignResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runGlimmer(struct soap *soap, struct ns1__runGlimmer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
	a->_params = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runGlimmer(struct soap *soap, const struct ns1__runGlimmer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
	soap_serialize_PointerTons1__glimmerInputParams(soap, &a->_params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runGlimmer(struct soap *soap, const struct ns1__runGlimmer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runGlimmer);
	if (soap_out_ns1__runGlimmer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runGlimmer(struct soap *soap, const char *tag, int id, const struct ns1__runGlimmer *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runGlimmer), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_PointerTons1__glimmerInputParams(soap, "params", -1, &a->_params, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runGlimmer * SOAP_FMAC4 soap_get_ns1__runGlimmer(struct soap *soap, struct ns1__runGlimmer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runGlimmer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runGlimmer * SOAP_FMAC4 soap_in_ns1__runGlimmer(struct soap *soap, const char *tag, struct ns1__runGlimmer *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runGlimmer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runGlimmer, sizeof(struct ns1__runGlimmer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runGlimmer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__glimmerInputParams(soap, NULL, &a->_params, "ns1:glimmerInputParams"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runGlimmer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runGlimmer, 0, sizeof(struct ns1__runGlimmer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runGlimmerResponse(struct soap *soap, struct ns1__runGlimmerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runGlimmerResponse(struct soap *soap, const struct ns1__runGlimmerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runGlimmerResponse(struct soap *soap, const struct ns1__runGlimmerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runGlimmerResponse);
	if (soap_out_ns1__runGlimmerResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runGlimmerResponse(struct soap *soap, const char *tag, int id, const struct ns1__runGlimmerResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runGlimmerResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runGlimmerResponse * SOAP_FMAC4 soap_get_ns1__runGlimmerResponse(struct soap *soap, struct ns1__runGlimmerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runGlimmerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runGlimmerResponse * SOAP_FMAC4 soap_in_ns1__runGlimmerResponse(struct soap *soap, const char *tag, struct ns1__runGlimmerResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runGlimmerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runGlimmerResponse, sizeof(struct ns1__runGlimmerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runGlimmerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runGlimmerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runGlimmerResponse, 0, sizeof(struct ns1__runGlimmerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runGenemarkhmm(struct soap *soap, struct ns1__runGenemarkhmm *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
	a->_params = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runGenemarkhmm(struct soap *soap, const struct ns1__runGenemarkhmm *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
	soap_serialize_PointerTons1__genemarkhmmInputParams(soap, &a->_params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runGenemarkhmm(struct soap *soap, const struct ns1__runGenemarkhmm *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runGenemarkhmm);
	if (soap_out_ns1__runGenemarkhmm(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runGenemarkhmm(struct soap *soap, const char *tag, int id, const struct ns1__runGenemarkhmm *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runGenemarkhmm), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_PointerTons1__genemarkhmmInputParams(soap, "params", -1, &a->_params, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runGenemarkhmm * SOAP_FMAC4 soap_get_ns1__runGenemarkhmm(struct soap *soap, struct ns1__runGenemarkhmm *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runGenemarkhmm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runGenemarkhmm * SOAP_FMAC4 soap_in_ns1__runGenemarkhmm(struct soap *soap, const char *tag, struct ns1__runGenemarkhmm *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runGenemarkhmm *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runGenemarkhmm, sizeof(struct ns1__runGenemarkhmm), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runGenemarkhmm(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__genemarkhmmInputParams(soap, NULL, &a->_params, "ns1:genemarkhmmInputParams"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runGenemarkhmm *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runGenemarkhmm, 0, sizeof(struct ns1__runGenemarkhmm), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runGenemarkhmmResponse(struct soap *soap, struct ns1__runGenemarkhmmResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runGenemarkhmmResponse(struct soap *soap, const struct ns1__runGenemarkhmmResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runGenemarkhmmResponse(struct soap *soap, const struct ns1__runGenemarkhmmResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runGenemarkhmmResponse);
	if (soap_out_ns1__runGenemarkhmmResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runGenemarkhmmResponse(struct soap *soap, const char *tag, int id, const struct ns1__runGenemarkhmmResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runGenemarkhmmResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runGenemarkhmmResponse * SOAP_FMAC4 soap_get_ns1__runGenemarkhmmResponse(struct soap *soap, struct ns1__runGenemarkhmmResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runGenemarkhmmResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runGenemarkhmmResponse * SOAP_FMAC4 soap_in_ns1__runGenemarkhmmResponse(struct soap *soap, const char *tag, struct ns1__runGenemarkhmmResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runGenemarkhmmResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runGenemarkhmmResponse, sizeof(struct ns1__runGenemarkhmmResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runGenemarkhmmResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runGenemarkhmmResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runGenemarkhmmResponse, 0, sizeof(struct ns1__runGenemarkhmmResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runFetchBatch(struct soap *soap, struct ns1__runFetchBatch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
	soap_default_string(soap, &a->_in1);
	a->_params = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runFetchBatch(struct soap *soap, const struct ns1__runFetchBatch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
	soap_serialize_string(soap, &a->_in1);
	soap_serialize_PointerTons1__fetchBatchInputParams(soap, &a->_params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runFetchBatch(struct soap *soap, const struct ns1__runFetchBatch *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runFetchBatch);
	if (soap_out_ns1__runFetchBatch(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runFetchBatch(struct soap *soap, const char *tag, int id, const struct ns1__runFetchBatch *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runFetchBatch), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_string(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	if (soap_out_PointerTons1__fetchBatchInputParams(soap, "params", -1, &a->_params, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runFetchBatch * SOAP_FMAC4 soap_get_ns1__runFetchBatch(struct soap *soap, struct ns1__runFetchBatch *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runFetchBatch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runFetchBatch * SOAP_FMAC4 soap_in_ns1__runFetchBatch(struct soap *soap, const char *tag, struct ns1__runFetchBatch *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	size_t soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runFetchBatch *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runFetchBatch, sizeof(struct ns1__runFetchBatch), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runFetchBatch(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap_flag__in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in1, "xsd:string"))
				{	soap_flag__in1--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__fetchBatchInputParams(soap, NULL, &a->_params, "ns1:fetchBatchInputParams"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runFetchBatch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runFetchBatch, 0, sizeof(struct ns1__runFetchBatch), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runFetchBatchResponse(struct soap *soap, struct ns1__runFetchBatchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runFetchBatchResponse(struct soap *soap, const struct ns1__runFetchBatchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runFetchBatchResponse(struct soap *soap, const struct ns1__runFetchBatchResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runFetchBatchResponse);
	if (soap_out_ns1__runFetchBatchResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runFetchBatchResponse(struct soap *soap, const char *tag, int id, const struct ns1__runFetchBatchResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runFetchBatchResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runFetchBatchResponse * SOAP_FMAC4 soap_get_ns1__runFetchBatchResponse(struct soap *soap, struct ns1__runFetchBatchResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runFetchBatchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runFetchBatchResponse * SOAP_FMAC4 soap_in_ns1__runFetchBatchResponse(struct soap *soap, const char *tag, struct ns1__runFetchBatchResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runFetchBatchResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runFetchBatchResponse, sizeof(struct ns1__runFetchBatchResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runFetchBatchResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runFetchBatchResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runFetchBatchResponse, 0, sizeof(struct ns1__runFetchBatchResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runFetchData(struct soap *soap, struct ns1__runFetchData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
	a->_params = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runFetchData(struct soap *soap, const struct ns1__runFetchData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
	soap_serialize_PointerTons1__fetchDataInputParams(soap, &a->_params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runFetchData(struct soap *soap, const struct ns1__runFetchData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runFetchData);
	if (soap_out_ns1__runFetchData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runFetchData(struct soap *soap, const char *tag, int id, const struct ns1__runFetchData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runFetchData), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_PointerTons1__fetchDataInputParams(soap, "params", -1, &a->_params, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runFetchData * SOAP_FMAC4 soap_get_ns1__runFetchData(struct soap *soap, struct ns1__runFetchData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runFetchData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runFetchData * SOAP_FMAC4 soap_in_ns1__runFetchData(struct soap *soap, const char *tag, struct ns1__runFetchData *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runFetchData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runFetchData, sizeof(struct ns1__runFetchData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runFetchData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__fetchDataInputParams(soap, NULL, &a->_params, "ns1:fetchDataInputParams"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runFetchData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runFetchData, 0, sizeof(struct ns1__runFetchData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runFetchDataResponse(struct soap *soap, struct ns1__runFetchDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runFetchDataResponse(struct soap *soap, const struct ns1__runFetchDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runFetchDataResponse(struct soap *soap, const struct ns1__runFetchDataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runFetchDataResponse);
	if (soap_out_ns1__runFetchDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runFetchDataResponse(struct soap *soap, const char *tag, int id, const struct ns1__runFetchDataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runFetchDataResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runFetchDataResponse * SOAP_FMAC4 soap_get_ns1__runFetchDataResponse(struct soap *soap, struct ns1__runFetchDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runFetchDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runFetchDataResponse * SOAP_FMAC4 soap_in_ns1__runFetchDataResponse(struct soap *soap, const char *tag, struct ns1__runFetchDataResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runFetchDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runFetchDataResponse, sizeof(struct ns1__runFetchDataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runFetchDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runFetchDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runFetchDataResponse, 0, sizeof(struct ns1__runFetchDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runClustalw(struct soap *soap, struct ns1__runClustalw *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
	a->_params = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runClustalw(struct soap *soap, const struct ns1__runClustalw *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
	soap_serialize_PointerTons1__clustalwInputParams(soap, &a->_params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runClustalw(struct soap *soap, const struct ns1__runClustalw *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runClustalw);
	if (soap_out_ns1__runClustalw(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runClustalw(struct soap *soap, const char *tag, int id, const struct ns1__runClustalw *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runClustalw), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_PointerTons1__clustalwInputParams(soap, "params", -1, &a->_params, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runClustalw * SOAP_FMAC4 soap_get_ns1__runClustalw(struct soap *soap, struct ns1__runClustalw *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runClustalw(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runClustalw * SOAP_FMAC4 soap_in_ns1__runClustalw(struct soap *soap, const char *tag, struct ns1__runClustalw *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runClustalw *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runClustalw, sizeof(struct ns1__runClustalw), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runClustalw(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__clustalwInputParams(soap, NULL, &a->_params, "ns1:clustalwInputParams"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runClustalw *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runClustalw, 0, sizeof(struct ns1__runClustalw), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runClustalwResponse(struct soap *soap, struct ns1__runClustalwResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runClustalwResponse(struct soap *soap, const struct ns1__runClustalwResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runClustalwResponse(struct soap *soap, const struct ns1__runClustalwResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runClustalwResponse);
	if (soap_out_ns1__runClustalwResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runClustalwResponse(struct soap *soap, const char *tag, int id, const struct ns1__runClustalwResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runClustalwResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runClustalwResponse * SOAP_FMAC4 soap_get_ns1__runClustalwResponse(struct soap *soap, struct ns1__runClustalwResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runClustalwResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runClustalwResponse * SOAP_FMAC4 soap_in_ns1__runClustalwResponse(struct soap *soap, const char *tag, struct ns1__runClustalwResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runClustalwResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runClustalwResponse, sizeof(struct ns1__runClustalwResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runClustalwResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runClustalwResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runClustalwResponse, 0, sizeof(struct ns1__runClustalwResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runCentroidfold(struct soap *soap, struct ns1__runCentroidfold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
	a->_params = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runCentroidfold(struct soap *soap, const struct ns1__runCentroidfold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
	soap_serialize_PointerTons1__centroidfoldInputParams(soap, &a->_params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runCentroidfold(struct soap *soap, const struct ns1__runCentroidfold *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runCentroidfold);
	if (soap_out_ns1__runCentroidfold(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runCentroidfold(struct soap *soap, const char *tag, int id, const struct ns1__runCentroidfold *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runCentroidfold), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_PointerTons1__centroidfoldInputParams(soap, "params", -1, &a->_params, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runCentroidfold * SOAP_FMAC4 soap_get_ns1__runCentroidfold(struct soap *soap, struct ns1__runCentroidfold *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runCentroidfold(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runCentroidfold * SOAP_FMAC4 soap_in_ns1__runCentroidfold(struct soap *soap, const char *tag, struct ns1__runCentroidfold *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runCentroidfold *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runCentroidfold, sizeof(struct ns1__runCentroidfold), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runCentroidfold(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__centroidfoldInputParams(soap, NULL, &a->_params, "ns1:centroidfoldInputParams"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runCentroidfold *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runCentroidfold, 0, sizeof(struct ns1__runCentroidfold), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runCentroidfoldResponse(struct soap *soap, struct ns1__runCentroidfoldResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runCentroidfoldResponse(struct soap *soap, const struct ns1__runCentroidfoldResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runCentroidfoldResponse(struct soap *soap, const struct ns1__runCentroidfoldResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runCentroidfoldResponse);
	if (soap_out_ns1__runCentroidfoldResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runCentroidfoldResponse(struct soap *soap, const char *tag, int id, const struct ns1__runCentroidfoldResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runCentroidfoldResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runCentroidfoldResponse * SOAP_FMAC4 soap_get_ns1__runCentroidfoldResponse(struct soap *soap, struct ns1__runCentroidfoldResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runCentroidfoldResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runCentroidfoldResponse * SOAP_FMAC4 soap_in_ns1__runCentroidfoldResponse(struct soap *soap, const char *tag, struct ns1__runCentroidfoldResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runCentroidfoldResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runCentroidfoldResponse, sizeof(struct ns1__runCentroidfoldResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runCentroidfoldResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runCentroidfoldResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runCentroidfoldResponse, 0, sizeof(struct ns1__runCentroidfoldResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runBlast(struct soap *soap, struct ns1__runBlast *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
	a->_params = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runBlast(struct soap *soap, const struct ns1__runBlast *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
	soap_serialize_PointerTons1__blastInputParams(soap, &a->_params);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runBlast(struct soap *soap, const struct ns1__runBlast *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runBlast);
	if (soap_out_ns1__runBlast(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runBlast(struct soap *soap, const char *tag, int id, const struct ns1__runBlast *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runBlast), type))
		return soap->error;
	if (soap_out_string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_PointerTons1__blastInputParams(soap, "params", -1, &a->_params, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runBlast * SOAP_FMAC4 soap_get_ns1__runBlast(struct soap *soap, struct ns1__runBlast *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runBlast(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runBlast * SOAP_FMAC4 soap_in_ns1__runBlast(struct soap *soap, const char *tag, struct ns1__runBlast *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runBlast *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runBlast, sizeof(struct ns1__runBlast), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runBlast(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__blastInputParams(soap, NULL, &a->_params, "ns1:blastInputParams"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runBlast *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runBlast, 0, sizeof(struct ns1__runBlast), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__runBlastResponse(struct soap *soap, struct ns1__runBlastResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobid = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__runBlastResponse(struct soap *soap, const struct ns1__runBlastResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->_jobid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__runBlastResponse(struct soap *soap, const struct ns1__runBlastResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__runBlastResponse);
	if (soap_out_ns1__runBlastResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__runBlastResponse(struct soap *soap, const char *tag, int id, const struct ns1__runBlastResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__runBlastResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "jobid", -1, &a->_jobid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__runBlastResponse * SOAP_FMAC4 soap_get_ns1__runBlastResponse(struct soap *soap, struct ns1__runBlastResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__runBlastResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__runBlastResponse * SOAP_FMAC4 soap_in_ns1__runBlastResponse(struct soap *soap, const char *tag, struct ns1__runBlastResponse *a, const char *type)
{
	size_t soap_flag__jobid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__runBlastResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__runBlastResponse, sizeof(struct ns1__runBlastResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__runBlastResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, NULL, &a->_jobid, "xsd:string"))
				{	soap_flag__jobid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__runBlastResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__runBlastResponse, 0, sizeof(struct ns1__runBlastResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__showBlastDBInputParams(struct soap *soap, struct ns1__showBlastDBInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->nucleotide);
	soap_default_xsd__boolean(soap, &a->protein);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__showBlastDBInputParams(struct soap *soap, const struct ns1__showBlastDBInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__showBlastDBInputParams(struct soap *soap, const struct ns1__showBlastDBInputParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__showBlastDBInputParams);
	if (soap_out_ns1__showBlastDBInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__showBlastDBInputParams(struct soap *soap, const char *tag, int id, const struct ns1__showBlastDBInputParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__showBlastDBInputParams), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "nucleotide", -1, &a->nucleotide, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "protein", -1, &a->protein, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__showBlastDBInputParams * SOAP_FMAC4 soap_get_ns1__showBlastDBInputParams(struct soap *soap, struct ns1__showBlastDBInputParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__showBlastDBInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__showBlastDBInputParams * SOAP_FMAC4 soap_in_ns1__showBlastDBInputParams(struct soap *soap, const char *tag, struct ns1__showBlastDBInputParams *a, const char *type)
{
	size_t soap_flag_nucleotide = 1;
	size_t soap_flag_protein = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__showBlastDBInputParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__showBlastDBInputParams, sizeof(struct ns1__showBlastDBInputParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__showBlastDBInputParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nucleotide && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "nucleotide", &a->nucleotide, "xsd:boolean"))
				{	soap_flag_nucleotide--;
					continue;
				}
			if (soap_flag_protein && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "protein", &a->protein, "xsd:boolean"))
				{	soap_flag_protein--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__showBlastDBInputParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__showBlastDBInputParams, 0, sizeof(struct ns1__showBlastDBInputParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nucleotide > 0 || soap_flag_protein > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__RNAfoldInputParams(struct soap *soap, struct ns1__RNAfoldInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->method);
	soap_default_xsd__boolean(soap, &a->noclosegu);
	soap_default_xsd__boolean(soap, &a->nolp);
	soap_default_string(soap, &a->dangling);
	soap_default_string(soap, &a->param);
	soap_default_int(soap, &a->tmp);
	soap_default_xsd__boolean(soap, &a->circ);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__RNAfoldInputParams(struct soap *soap, const struct ns1__RNAfoldInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->method);
	soap_serialize_string(soap, &a->dangling);
	soap_serialize_string(soap, &a->param);
	soap_embedded(soap, &a->tmp, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__RNAfoldInputParams(struct soap *soap, const struct ns1__RNAfoldInputParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__RNAfoldInputParams);
	if (soap_out_ns1__RNAfoldInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RNAfoldInputParams(struct soap *soap, const char *tag, int id, const struct ns1__RNAfoldInputParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RNAfoldInputParams), type))
		return soap->error;
	if (soap_out_string(soap, "method", -1, &a->method, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "noclosegu", -1, &a->noclosegu, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "nolp", -1, &a->nolp, ""))
		return soap->error;
	if (soap_out_string(soap, "dangling", -1, &a->dangling, ""))
		return soap->error;
	if (soap_out_string(soap, "param", -1, &a->param, ""))
		return soap->error;
	if (soap_out_int(soap, "tmp", -1, &a->tmp, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "circ", -1, &a->circ, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__RNAfoldInputParams * SOAP_FMAC4 soap_get_ns1__RNAfoldInputParams(struct soap *soap, struct ns1__RNAfoldInputParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RNAfoldInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__RNAfoldInputParams * SOAP_FMAC4 soap_in_ns1__RNAfoldInputParams(struct soap *soap, const char *tag, struct ns1__RNAfoldInputParams *a, const char *type)
{
	size_t soap_flag_method = 1;
	size_t soap_flag_noclosegu = 1;
	size_t soap_flag_nolp = 1;
	size_t soap_flag_dangling = 1;
	size_t soap_flag_param = 1;
	size_t soap_flag_tmp = 1;
	size_t soap_flag_circ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__RNAfoldInputParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RNAfoldInputParams, sizeof(struct ns1__RNAfoldInputParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__RNAfoldInputParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_method && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "method", &a->method, "xsd:string"))
				{	soap_flag_method--;
					continue;
				}
			if (soap_flag_noclosegu && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "noclosegu", &a->noclosegu, "xsd:boolean"))
				{	soap_flag_noclosegu--;
					continue;
				}
			if (soap_flag_nolp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "nolp", &a->nolp, "xsd:boolean"))
				{	soap_flag_nolp--;
					continue;
				}
			if (soap_flag_dangling && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dangling", &a->dangling, "xsd:string"))
				{	soap_flag_dangling--;
					continue;
				}
			if (soap_flag_param && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "param", &a->param, "xsd:string"))
				{	soap_flag_param--;
					continue;
				}
			if (soap_flag_tmp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tmp", &a->tmp, "xsd:int"))
				{	soap_flag_tmp--;
					continue;
				}
			if (soap_flag_circ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "circ", &a->circ, "xsd:boolean"))
				{	soap_flag_circ--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__RNAfoldInputParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RNAfoldInputParams, 0, sizeof(struct ns1__RNAfoldInputParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_method > 0 || soap_flag_noclosegu > 0 || soap_flag_nolp > 0 || soap_flag_dangling > 0 || soap_flag_param > 0 || soap_flag_tmp > 0 || soap_flag_circ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__wolfPsortInputParams(struct soap *soap, struct ns1__wolfPsortInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->org);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__wolfPsortInputParams(struct soap *soap, const struct ns1__wolfPsortInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->org);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__wolfPsortInputParams(struct soap *soap, const struct ns1__wolfPsortInputParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__wolfPsortInputParams);
	if (soap_out_ns1__wolfPsortInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__wolfPsortInputParams(struct soap *soap, const char *tag, int id, const struct ns1__wolfPsortInputParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__wolfPsortInputParams), type))
		return soap->error;
	if (soap_out_string(soap, "org", -1, &a->org, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__wolfPsortInputParams * SOAP_FMAC4 soap_get_ns1__wolfPsortInputParams(struct soap *soap, struct ns1__wolfPsortInputParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__wolfPsortInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__wolfPsortInputParams * SOAP_FMAC4 soap_in_ns1__wolfPsortInputParams(struct soap *soap, const char *tag, struct ns1__wolfPsortInputParams *a, const char *type)
{
	size_t soap_flag_org = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__wolfPsortInputParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__wolfPsortInputParams, sizeof(struct ns1__wolfPsortInputParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__wolfPsortInputParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_org && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "org", &a->org, "xsd:string"))
				{	soap_flag_org--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__wolfPsortInputParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__wolfPsortInputParams, 0, sizeof(struct ns1__wolfPsortInputParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_org > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__weblogoInputParams(struct soap *soap, struct ns1__weblogoInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->format);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__weblogoInputParams(struct soap *soap, const struct ns1__weblogoInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->format);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__weblogoInputParams(struct soap *soap, const struct ns1__weblogoInputParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__weblogoInputParams);
	if (soap_out_ns1__weblogoInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__weblogoInputParams(struct soap *soap, const char *tag, int id, const struct ns1__weblogoInputParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__weblogoInputParams), type))
		return soap->error;
	if (soap_out_string(soap, "format", -1, &a->format, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__weblogoInputParams * SOAP_FMAC4 soap_get_ns1__weblogoInputParams(struct soap *soap, struct ns1__weblogoInputParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__weblogoInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__weblogoInputParams * SOAP_FMAC4 soap_in_ns1__weblogoInputParams(struct soap *soap, const char *tag, struct ns1__weblogoInputParams *a, const char *type)
{
	size_t soap_flag_format = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__weblogoInputParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__weblogoInputParams, sizeof(struct ns1__weblogoInputParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__weblogoInputParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_format && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "format", &a->format, "xsd:string"))
				{	soap_flag_format--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__weblogoInputParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__weblogoInputParams, 0, sizeof(struct ns1__weblogoInputParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_format > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ssearchInputParams(struct soap *soap, struct ns1__ssearchInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->d);
	soap_default_string(soap, &a->moltype);
	soap_default_xsd__boolean(soap, &a->histogram);
	soap_default_xsd__boolean(soap, &a->nucleotide);
	soap_default_xsd__boolean(soap, &a->topstrand);
	soap_default_xsd__boolean(soap, &a->bottomstrand);
	soap_default_int(soap, &a->gapopen);
	soap_default_int(soap, &a->gapext);
	soap_default_int(soap, &a->scores);
	soap_default_int(soap, &a->alignments);
	soap_default_int(soap, &a->ktup);
	soap_default_string(soap, &a->matrix);
	soap_default_float(soap, &a->eupper);
	soap_default_float(soap, &a->elower);
	soap_default_string(soap, &a->dbrange);
	soap_default_string(soap, &a->seqrange);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ssearchInputParams(struct soap *soap, const struct ns1__ssearchInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->d);
	soap_serialize_string(soap, &a->moltype);
	soap_embedded(soap, &a->gapopen, SOAP_TYPE_int);
	soap_embedded(soap, &a->gapext, SOAP_TYPE_int);
	soap_embedded(soap, &a->scores, SOAP_TYPE_int);
	soap_embedded(soap, &a->alignments, SOAP_TYPE_int);
	soap_embedded(soap, &a->ktup, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->matrix);
	soap_serialize_string(soap, &a->dbrange);
	soap_serialize_string(soap, &a->seqrange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ssearchInputParams(struct soap *soap, const struct ns1__ssearchInputParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ssearchInputParams);
	if (soap_out_ns1__ssearchInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ssearchInputParams(struct soap *soap, const char *tag, int id, const struct ns1__ssearchInputParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ssearchInputParams), type))
		return soap->error;
	if (soap_out_string(soap, "d", -1, &a->d, ""))
		return soap->error;
	if (soap_out_string(soap, "moltype", -1, &a->moltype, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "histogram", -1, &a->histogram, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "nucleotide", -1, &a->nucleotide, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "topstrand", -1, &a->topstrand, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "bottomstrand", -1, &a->bottomstrand, ""))
		return soap->error;
	if (soap_out_int(soap, "gapopen", -1, &a->gapopen, ""))
		return soap->error;
	if (soap_out_int(soap, "gapext", -1, &a->gapext, ""))
		return soap->error;
	if (soap_out_int(soap, "scores", -1, &a->scores, ""))
		return soap->error;
	if (soap_out_int(soap, "alignments", -1, &a->alignments, ""))
		return soap->error;
	if (soap_out_int(soap, "ktup", -1, &a->ktup, ""))
		return soap->error;
	if (soap_out_string(soap, "matrix", -1, &a->matrix, ""))
		return soap->error;
	if (soap_out_float(soap, "eupper", -1, &a->eupper, ""))
		return soap->error;
	if (soap_out_float(soap, "elower", -1, &a->elower, ""))
		return soap->error;
	if (soap_out_string(soap, "dbrange", -1, &a->dbrange, ""))
		return soap->error;
	if (soap_out_string(soap, "seqrange", -1, &a->seqrange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ssearchInputParams * SOAP_FMAC4 soap_get_ns1__ssearchInputParams(struct soap *soap, struct ns1__ssearchInputParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ssearchInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ssearchInputParams * SOAP_FMAC4 soap_in_ns1__ssearchInputParams(struct soap *soap, const char *tag, struct ns1__ssearchInputParams *a, const char *type)
{
	size_t soap_flag_d = 1;
	size_t soap_flag_moltype = 1;
	size_t soap_flag_histogram = 1;
	size_t soap_flag_nucleotide = 1;
	size_t soap_flag_topstrand = 1;
	size_t soap_flag_bottomstrand = 1;
	size_t soap_flag_gapopen = 1;
	size_t soap_flag_gapext = 1;
	size_t soap_flag_scores = 1;
	size_t soap_flag_alignments = 1;
	size_t soap_flag_ktup = 1;
	size_t soap_flag_matrix = 1;
	size_t soap_flag_eupper = 1;
	size_t soap_flag_elower = 1;
	size_t soap_flag_dbrange = 1;
	size_t soap_flag_seqrange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ssearchInputParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ssearchInputParams, sizeof(struct ns1__ssearchInputParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ssearchInputParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_d && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "d", &a->d, "xsd:string"))
				{	soap_flag_d--;
					continue;
				}
			if (soap_flag_moltype && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "moltype", &a->moltype, "xsd:string"))
				{	soap_flag_moltype--;
					continue;
				}
			if (soap_flag_histogram && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "histogram", &a->histogram, "xsd:boolean"))
				{	soap_flag_histogram--;
					continue;
				}
			if (soap_flag_nucleotide && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "nucleotide", &a->nucleotide, "xsd:boolean"))
				{	soap_flag_nucleotide--;
					continue;
				}
			if (soap_flag_topstrand && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "topstrand", &a->topstrand, "xsd:boolean"))
				{	soap_flag_topstrand--;
					continue;
				}
			if (soap_flag_bottomstrand && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "bottomstrand", &a->bottomstrand, "xsd:boolean"))
				{	soap_flag_bottomstrand--;
					continue;
				}
			if (soap_flag_gapopen && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "gapopen", &a->gapopen, "xsd:int"))
				{	soap_flag_gapopen--;
					continue;
				}
			if (soap_flag_gapext && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "gapext", &a->gapext, "xsd:int"))
				{	soap_flag_gapext--;
					continue;
				}
			if (soap_flag_scores && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "scores", &a->scores, "xsd:int"))
				{	soap_flag_scores--;
					continue;
				}
			if (soap_flag_alignments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "alignments", &a->alignments, "xsd:int"))
				{	soap_flag_alignments--;
					continue;
				}
			if (soap_flag_ktup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ktup", &a->ktup, "xsd:int"))
				{	soap_flag_ktup--;
					continue;
				}
			if (soap_flag_matrix && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "matrix", &a->matrix, "xsd:string"))
				{	soap_flag_matrix--;
					continue;
				}
			if (soap_flag_eupper && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "eupper", &a->eupper, "xsd:float"))
				{	soap_flag_eupper--;
					continue;
				}
			if (soap_flag_elower && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "elower", &a->elower, "xsd:float"))
				{	soap_flag_elower--;
					continue;
				}
			if (soap_flag_dbrange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dbrange", &a->dbrange, "xsd:string"))
				{	soap_flag_dbrange--;
					continue;
				}
			if (soap_flag_seqrange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "seqrange", &a->seqrange, "xsd:string"))
				{	soap_flag_seqrange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ssearchInputParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ssearchInputParams, 0, sizeof(struct ns1__ssearchInputParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_d > 0 || soap_flag_moltype > 0 || soap_flag_histogram > 0 || soap_flag_nucleotide > 0 || soap_flag_topstrand > 0 || soap_flag_bottomstrand > 0 || soap_flag_gapopen > 0 || soap_flag_gapext > 0 || soap_flag_scores > 0 || soap_flag_alignments > 0 || soap_flag_ktup > 0 || soap_flag_matrix > 0 || soap_flag_eupper > 0 || soap_flag_elower > 0 || soap_flag_dbrange > 0 || soap_flag_seqrange > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__tRNAscanInputParams(struct soap *soap, struct ns1__tRNAscanInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->title);
	soap_default_string(soap, &a->mode);
	soap_default_string(soap, &a->source);
	soap_default_string(soap, &a->gcode);
	soap_default_xsd__boolean(soap, &a->pesudogene);
	soap_default_xsd__boolean(soap, &a->origin);
	soap_default_xsd__boolean(soap, &a->ace);
	soap_default_xsd__boolean(soap, &a->codons);
	soap_default_xsd__boolean(soap, &a->fpos);
	soap_default_xsd__boolean(soap, &a->breakdown);
	soap_default_string(soap, &a->covescore);
	soap_default_string(soap, &a->euparams);
	soap_default_string(soap, &a->euscore);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__tRNAscanInputParams(struct soap *soap, const struct ns1__tRNAscanInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->title);
	soap_serialize_string(soap, &a->mode);
	soap_serialize_string(soap, &a->source);
	soap_serialize_string(soap, &a->gcode);
	soap_serialize_string(soap, &a->covescore);
	soap_serialize_string(soap, &a->euparams);
	soap_serialize_string(soap, &a->euscore);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__tRNAscanInputParams(struct soap *soap, const struct ns1__tRNAscanInputParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__tRNAscanInputParams);
	if (soap_out_ns1__tRNAscanInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__tRNAscanInputParams(struct soap *soap, const char *tag, int id, const struct ns1__tRNAscanInputParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__tRNAscanInputParams), type))
		return soap->error;
	if (soap_out_string(soap, "title", -1, &a->title, ""))
		return soap->error;
	if (soap_out_string(soap, "mode", -1, &a->mode, ""))
		return soap->error;
	if (soap_out_string(soap, "source", -1, &a->source, ""))
		return soap->error;
	if (soap_out_string(soap, "gcode", -1, &a->gcode, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "pesudogene", -1, &a->pesudogene, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "origin", -1, &a->origin, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ace", -1, &a->ace, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "codons", -1, &a->codons, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "fpos", -1, &a->fpos, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "breakdown", -1, &a->breakdown, ""))
		return soap->error;
	if (soap_out_string(soap, "covescore", -1, &a->covescore, ""))
		return soap->error;
	if (soap_out_string(soap, "euparams", -1, &a->euparams, ""))
		return soap->error;
	if (soap_out_string(soap, "euscore", -1, &a->euscore, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__tRNAscanInputParams * SOAP_FMAC4 soap_get_ns1__tRNAscanInputParams(struct soap *soap, struct ns1__tRNAscanInputParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__tRNAscanInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__tRNAscanInputParams * SOAP_FMAC4 soap_in_ns1__tRNAscanInputParams(struct soap *soap, const char *tag, struct ns1__tRNAscanInputParams *a, const char *type)
{
	size_t soap_flag_title = 1;
	size_t soap_flag_mode = 1;
	size_t soap_flag_source = 1;
	size_t soap_flag_gcode = 1;
	size_t soap_flag_pesudogene = 1;
	size_t soap_flag_origin = 1;
	size_t soap_flag_ace = 1;
	size_t soap_flag_codons = 1;
	size_t soap_flag_fpos = 1;
	size_t soap_flag_breakdown = 1;
	size_t soap_flag_covescore = 1;
	size_t soap_flag_euparams = 1;
	size_t soap_flag_euscore = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__tRNAscanInputParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__tRNAscanInputParams, sizeof(struct ns1__tRNAscanInputParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__tRNAscanInputParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_title && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "title", &a->title, "xsd:string"))
				{	soap_flag_title--;
					continue;
				}
			if (soap_flag_mode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "mode", &a->mode, "xsd:string"))
				{	soap_flag_mode--;
					continue;
				}
			if (soap_flag_source && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "source", &a->source, "xsd:string"))
				{	soap_flag_source--;
					continue;
				}
			if (soap_flag_gcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "gcode", &a->gcode, "xsd:string"))
				{	soap_flag_gcode--;
					continue;
				}
			if (soap_flag_pesudogene && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "pesudogene", &a->pesudogene, "xsd:boolean"))
				{	soap_flag_pesudogene--;
					continue;
				}
			if (soap_flag_origin && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "origin", &a->origin, "xsd:boolean"))
				{	soap_flag_origin--;
					continue;
				}
			if (soap_flag_ace && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ace", &a->ace, "xsd:boolean"))
				{	soap_flag_ace--;
					continue;
				}
			if (soap_flag_codons && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "codons", &a->codons, "xsd:boolean"))
				{	soap_flag_codons--;
					continue;
				}
			if (soap_flag_fpos && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "fpos", &a->fpos, "xsd:boolean"))
				{	soap_flag_fpos--;
					continue;
				}
			if (soap_flag_breakdown && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "breakdown", &a->breakdown, "xsd:boolean"))
				{	soap_flag_breakdown--;
					continue;
				}
			if (soap_flag_covescore && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "covescore", &a->covescore, "xsd:string"))
				{	soap_flag_covescore--;
					continue;
				}
			if (soap_flag_euparams && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "euparams", &a->euparams, "xsd:string"))
				{	soap_flag_euparams--;
					continue;
				}
			if (soap_flag_euscore && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "euscore", &a->euscore, "xsd:string"))
				{	soap_flag_euscore--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__tRNAscanInputParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__tRNAscanInputParams, 0, sizeof(struct ns1__tRNAscanInputParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_title > 0 || soap_flag_mode > 0 || soap_flag_source > 0 || soap_flag_gcode > 0 || soap_flag_pesudogene > 0 || soap_flag_origin > 0 || soap_flag_ace > 0 || soap_flag_codons > 0 || soap_flag_fpos > 0 || soap_flag_breakdown > 0 || soap_flag_covescore > 0 || soap_flag_euparams > 0 || soap_flag_euscore > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__tcoffeeInputParams(struct soap *soap, struct ns1__tcoffeeInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->matrix);
	soap_default_string(soap, &a->outorder);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__tcoffeeInputParams(struct soap *soap, const struct ns1__tcoffeeInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->matrix);
	soap_serialize_string(soap, &a->outorder);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__tcoffeeInputParams(struct soap *soap, const struct ns1__tcoffeeInputParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__tcoffeeInputParams);
	if (soap_out_ns1__tcoffeeInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__tcoffeeInputParams(struct soap *soap, const char *tag, int id, const struct ns1__tcoffeeInputParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__tcoffeeInputParams), type))
		return soap->error;
	if (soap_out_string(soap, "matrix", -1, &a->matrix, ""))
		return soap->error;
	if (soap_out_string(soap, "outorder", -1, &a->outorder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__tcoffeeInputParams * SOAP_FMAC4 soap_get_ns1__tcoffeeInputParams(struct soap *soap, struct ns1__tcoffeeInputParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__tcoffeeInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__tcoffeeInputParams * SOAP_FMAC4 soap_in_ns1__tcoffeeInputParams(struct soap *soap, const char *tag, struct ns1__tcoffeeInputParams *a, const char *type)
{
	size_t soap_flag_matrix = 1;
	size_t soap_flag_outorder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__tcoffeeInputParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__tcoffeeInputParams, sizeof(struct ns1__tcoffeeInputParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__tcoffeeInputParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_matrix && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "matrix", &a->matrix, "xsd:string"))
				{	soap_flag_matrix--;
					continue;
				}
			if (soap_flag_outorder && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "outorder", &a->outorder, "xsd:string"))
				{	soap_flag_outorder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__tcoffeeInputParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__tcoffeeInputParams, 0, sizeof(struct ns1__tcoffeeInputParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_matrix > 0 || soap_flag_outorder > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__psortbInputParams(struct soap *soap, struct ns1__psortbInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->format);
	soap_default_string(soap, &a->gram);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__psortbInputParams(struct soap *soap, const struct ns1__psortbInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->format);
	soap_serialize_string(soap, &a->gram);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__psortbInputParams(struct soap *soap, const struct ns1__psortbInputParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__psortbInputParams);
	if (soap_out_ns1__psortbInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__psortbInputParams(struct soap *soap, const char *tag, int id, const struct ns1__psortbInputParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__psortbInputParams), type))
		return soap->error;
	if (soap_out_string(soap, "format", -1, &a->format, ""))
		return soap->error;
	if (soap_out_string(soap, "gram", -1, &a->gram, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__psortbInputParams * SOAP_FMAC4 soap_get_ns1__psortbInputParams(struct soap *soap, struct ns1__psortbInputParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__psortbInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__psortbInputParams * SOAP_FMAC4 soap_in_ns1__psortbInputParams(struct soap *soap, const char *tag, struct ns1__psortbInputParams *a, const char *type)
{
	size_t soap_flag_format = 1;
	size_t soap_flag_gram = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__psortbInputParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__psortbInputParams, sizeof(struct ns1__psortbInputParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__psortbInputParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_format && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "format", &a->format, "xsd:string"))
				{	soap_flag_format--;
					continue;
				}
			if (soap_flag_gram && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "gram", &a->gram, "xsd:string"))
				{	soap_flag_gram--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__psortbInputParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__psortbInputParams, 0, sizeof(struct ns1__psortbInputParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_format > 0 || soap_flag_gram > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__psortInputParams(struct soap *soap, struct ns1__psortInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->org);
	soap_default_string(soap, &a->title);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__psortInputParams(struct soap *soap, const struct ns1__psortInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->org);
	soap_serialize_string(soap, &a->title);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__psortInputParams(struct soap *soap, const struct ns1__psortInputParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__psortInputParams);
	if (soap_out_ns1__psortInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__psortInputParams(struct soap *soap, const char *tag, int id, const struct ns1__psortInputParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__psortInputParams), type))
		return soap->error;
	if (soap_out_string(soap, "org", -1, &a->org, ""))
		return soap->error;
	if (soap_out_string(soap, "title", -1, &a->title, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__psortInputParams * SOAP_FMAC4 soap_get_ns1__psortInputParams(struct soap *soap, struct ns1__psortInputParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__psortInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__psortInputParams * SOAP_FMAC4 soap_in_ns1__psortInputParams(struct soap *soap, const char *tag, struct ns1__psortInputParams *a, const char *type)
{
	size_t soap_flag_org = 1;
	size_t soap_flag_title = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__psortInputParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__psortInputParams, sizeof(struct ns1__psortInputParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__psortInputParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_org && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "org", &a->org, "xsd:string"))
				{	soap_flag_org--;
					continue;
				}
			if (soap_flag_title && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "title", &a->title, "xsd:string"))
				{	soap_flag_title--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__psortInputParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__psortInputParams, 0, sizeof(struct ns1__psortInputParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_org > 0 || soap_flag_title > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__phobiusInputParams(struct soap *soap, struct ns1__phobiusInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->outputformat);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__phobiusInputParams(struct soap *soap, const struct ns1__phobiusInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->outputformat);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__phobiusInputParams(struct soap *soap, const struct ns1__phobiusInputParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__phobiusInputParams);
	if (soap_out_ns1__phobiusInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__phobiusInputParams(struct soap *soap, const char *tag, int id, const struct ns1__phobiusInputParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__phobiusInputParams), type))
		return soap->error;
	if (soap_out_string(soap, "outputformat", -1, &a->outputformat, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__phobiusInputParams * SOAP_FMAC4 soap_get_ns1__phobiusInputParams(struct soap *soap, struct ns1__phobiusInputParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__phobiusInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__phobiusInputParams * SOAP_FMAC4 soap_in_ns1__phobiusInputParams(struct soap *soap, const char *tag, struct ns1__phobiusInputParams *a, const char *type)
{
	size_t soap_flag_outputformat = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__phobiusInputParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__phobiusInputParams, sizeof(struct ns1__phobiusInputParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__phobiusInputParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outputformat && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "outputformat", &a->outputformat, "xsd:string"))
				{	soap_flag_outputformat--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__phobiusInputParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__phobiusInputParams, 0, sizeof(struct ns1__phobiusInputParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_outputformat > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__muscleInputParams(struct soap *soap, struct ns1__muscleInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->output);
	soap_default_string(soap, &a->outorder);
	soap_default_float(soap, &a->gapopen);
	soap_default_float(soap, &a->gapextend);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__muscleInputParams(struct soap *soap, const struct ns1__muscleInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->output);
	soap_serialize_string(soap, &a->outorder);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__muscleInputParams(struct soap *soap, const struct ns1__muscleInputParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__muscleInputParams);
	if (soap_out_ns1__muscleInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__muscleInputParams(struct soap *soap, const char *tag, int id, const struct ns1__muscleInputParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__muscleInputParams), type))
		return soap->error;
	if (soap_out_string(soap, "output", -1, &a->output, ""))
		return soap->error;
	if (soap_out_string(soap, "outorder", -1, &a->outorder, ""))
		return soap->error;
	if (soap_out_float(soap, "gapopen", -1, &a->gapopen, ""))
		return soap->error;
	if (soap_out_float(soap, "gapextend", -1, &a->gapextend, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__muscleInputParams * SOAP_FMAC4 soap_get_ns1__muscleInputParams(struct soap *soap, struct ns1__muscleInputParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__muscleInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__muscleInputParams * SOAP_FMAC4 soap_in_ns1__muscleInputParams(struct soap *soap, const char *tag, struct ns1__muscleInputParams *a, const char *type)
{
	size_t soap_flag_output = 1;
	size_t soap_flag_outorder = 1;
	size_t soap_flag_gapopen = 1;
	size_t soap_flag_gapextend = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__muscleInputParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__muscleInputParams, sizeof(struct ns1__muscleInputParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__muscleInputParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_output && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "output", &a->output, "xsd:string"))
				{	soap_flag_output--;
					continue;
				}
			if (soap_flag_outorder && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "outorder", &a->outorder, "xsd:string"))
				{	soap_flag_outorder--;
					continue;
				}
			if (soap_flag_gapopen && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "gapopen", &a->gapopen, "xsd:float"))
				{	soap_flag_gapopen--;
					continue;
				}
			if (soap_flag_gapextend && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "gapextend", &a->gapextend, "xsd:float"))
				{	soap_flag_gapextend--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__muscleInputParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__muscleInputParams, 0, sizeof(struct ns1__muscleInputParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_output > 0 || soap_flag_outorder > 0 || soap_flag_gapopen > 0 || soap_flag_gapextend > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mafftInputParams(struct soap *soap, struct ns1__mafftInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->strategy);
	soap_default_string(soap, &a->outorder);
	soap_default_float(soap, &a->op);
	soap_default_float(soap, &a->ep);
	soap_default_string(soap, &a->scorematrix);
	soap_default_xsd__boolean(soap, &a->homologs);
	soap_default_xsd__boolean(soap, &a->showhomologs);
	soap_default_int(soap, &a->numhomologs);
	soap_default_float(soap, &a->threshold);
	soap_default_string(soap, &a->referenceseq);
	soap_default_string(soap, &a->harrplot);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mafftInputParams(struct soap *soap, const struct ns1__mafftInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->strategy);
	soap_serialize_string(soap, &a->outorder);
	soap_serialize_string(soap, &a->scorematrix);
	soap_embedded(soap, &a->numhomologs, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->referenceseq);
	soap_serialize_string(soap, &a->harrplot);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mafftInputParams(struct soap *soap, const struct ns1__mafftInputParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mafftInputParams);
	if (soap_out_ns1__mafftInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mafftInputParams(struct soap *soap, const char *tag, int id, const struct ns1__mafftInputParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mafftInputParams), type))
		return soap->error;
	if (soap_out_string(soap, "strategy", -1, &a->strategy, ""))
		return soap->error;
	if (soap_out_string(soap, "outorder", -1, &a->outorder, ""))
		return soap->error;
	if (soap_out_float(soap, "op", -1, &a->op, ""))
		return soap->error;
	if (soap_out_float(soap, "ep", -1, &a->ep, ""))
		return soap->error;
	if (soap_out_string(soap, "scorematrix", -1, &a->scorematrix, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "homologs", -1, &a->homologs, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "showhomologs", -1, &a->showhomologs, ""))
		return soap->error;
	if (soap_out_int(soap, "numhomologs", -1, &a->numhomologs, ""))
		return soap->error;
	if (soap_out_float(soap, "threshold", -1, &a->threshold, ""))
		return soap->error;
	if (soap_out_string(soap, "referenceseq", -1, &a->referenceseq, ""))
		return soap->error;
	if (soap_out_string(soap, "harrplot", -1, &a->harrplot, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mafftInputParams * SOAP_FMAC4 soap_get_ns1__mafftInputParams(struct soap *soap, struct ns1__mafftInputParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mafftInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__mafftInputParams * SOAP_FMAC4 soap_in_ns1__mafftInputParams(struct soap *soap, const char *tag, struct ns1__mafftInputParams *a, const char *type)
{
	size_t soap_flag_strategy = 1;
	size_t soap_flag_outorder = 1;
	size_t soap_flag_op = 1;
	size_t soap_flag_ep = 1;
	size_t soap_flag_scorematrix = 1;
	size_t soap_flag_homologs = 1;
	size_t soap_flag_showhomologs = 1;
	size_t soap_flag_numhomologs = 1;
	size_t soap_flag_threshold = 1;
	size_t soap_flag_referenceseq = 1;
	size_t soap_flag_harrplot = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mafftInputParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mafftInputParams, sizeof(struct ns1__mafftInputParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mafftInputParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strategy && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "strategy", &a->strategy, "xsd:string"))
				{	soap_flag_strategy--;
					continue;
				}
			if (soap_flag_outorder && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "outorder", &a->outorder, "xsd:string"))
				{	soap_flag_outorder--;
					continue;
				}
			if (soap_flag_op && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "op", &a->op, "xsd:float"))
				{	soap_flag_op--;
					continue;
				}
			if (soap_flag_ep && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ep", &a->ep, "xsd:float"))
				{	soap_flag_ep--;
					continue;
				}
			if (soap_flag_scorematrix && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "scorematrix", &a->scorematrix, "xsd:string"))
				{	soap_flag_scorematrix--;
					continue;
				}
			if (soap_flag_homologs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "homologs", &a->homologs, "xsd:boolean"))
				{	soap_flag_homologs--;
					continue;
				}
			if (soap_flag_showhomologs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "showhomologs", &a->showhomologs, "xsd:boolean"))
				{	soap_flag_showhomologs--;
					continue;
				}
			if (soap_flag_numhomologs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numhomologs", &a->numhomologs, "xsd:int"))
				{	soap_flag_numhomologs--;
					continue;
				}
			if (soap_flag_threshold && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "threshold", &a->threshold, "xsd:float"))
				{	soap_flag_threshold--;
					continue;
				}
			if (soap_flag_referenceseq && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "referenceseq", &a->referenceseq, "xsd:string"))
				{	soap_flag_referenceseq--;
					continue;
				}
			if (soap_flag_harrplot && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "harrplot", &a->harrplot, "xsd:string"))
				{	soap_flag_harrplot--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mafftInputParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mafftInputParams, 0, sizeof(struct ns1__mafftInputParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_strategy > 0 || soap_flag_outorder > 0 || soap_flag_op > 0 || soap_flag_ep > 0 || soap_flag_scorematrix > 0 || soap_flag_homologs > 0 || soap_flag_showhomologs > 0 || soap_flag_numhomologs > 0 || soap_flag_threshold > 0 || soap_flag_referenceseq > 0 || soap_flag_harrplot > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__kalignInputParams(struct soap *soap, struct ns1__kalignInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->moltype);
	soap_default_float(soap, &a->gpo);
	soap_default_float(soap, &a->gpe);
	soap_default_float(soap, &a->tgpe);
	soap_default_float(soap, &a->bonus);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__kalignInputParams(struct soap *soap, const struct ns1__kalignInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->moltype);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__kalignInputParams(struct soap *soap, const struct ns1__kalignInputParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__kalignInputParams);
	if (soap_out_ns1__kalignInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__kalignInputParams(struct soap *soap, const char *tag, int id, const struct ns1__kalignInputParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__kalignInputParams), type))
		return soap->error;
	if (soap_out_string(soap, "moltype", -1, &a->moltype, ""))
		return soap->error;
	if (soap_out_float(soap, "gpo", -1, &a->gpo, ""))
		return soap->error;
	if (soap_out_float(soap, "gpe", -1, &a->gpe, ""))
		return soap->error;
	if (soap_out_float(soap, "tgpe", -1, &a->tgpe, ""))
		return soap->error;
	if (soap_out_float(soap, "bonus", -1, &a->bonus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__kalignInputParams * SOAP_FMAC4 soap_get_ns1__kalignInputParams(struct soap *soap, struct ns1__kalignInputParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__kalignInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__kalignInputParams * SOAP_FMAC4 soap_in_ns1__kalignInputParams(struct soap *soap, const char *tag, struct ns1__kalignInputParams *a, const char *type)
{
	size_t soap_flag_moltype = 1;
	size_t soap_flag_gpo = 1;
	size_t soap_flag_gpe = 1;
	size_t soap_flag_tgpe = 1;
	size_t soap_flag_bonus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__kalignInputParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__kalignInputParams, sizeof(struct ns1__kalignInputParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__kalignInputParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_moltype && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "moltype", &a->moltype, "xsd:string"))
				{	soap_flag_moltype--;
					continue;
				}
			if (soap_flag_gpo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "gpo", &a->gpo, "xsd:float"))
				{	soap_flag_gpo--;
					continue;
				}
			if (soap_flag_gpe && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "gpe", &a->gpe, "xsd:float"))
				{	soap_flag_gpe--;
					continue;
				}
			if (soap_flag_tgpe && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tgpe", &a->tgpe, "xsd:float"))
				{	soap_flag_tgpe--;
					continue;
				}
			if (soap_flag_bonus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "bonus", &a->bonus, "xsd:float"))
				{	soap_flag_bonus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__kalignInputParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__kalignInputParams, 0, sizeof(struct ns1__kalignInputParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_moltype > 0 || soap_flag_gpo > 0 || soap_flag_gpe > 0 || soap_flag_tgpe > 0 || soap_flag_bonus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__glimmerInputParams(struct soap *soap, struct ns1__glimmerInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->gencode);
	soap_default_string(soap, &a->topology);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__glimmerInputParams(struct soap *soap, const struct ns1__glimmerInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->gencode, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->topology);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__glimmerInputParams(struct soap *soap, const struct ns1__glimmerInputParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__glimmerInputParams);
	if (soap_out_ns1__glimmerInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__glimmerInputParams(struct soap *soap, const char *tag, int id, const struct ns1__glimmerInputParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__glimmerInputParams), type))
		return soap->error;
	if (soap_out_int(soap, "gencode", -1, &a->gencode, ""))
		return soap->error;
	if (soap_out_string(soap, "topology", -1, &a->topology, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__glimmerInputParams * SOAP_FMAC4 soap_get_ns1__glimmerInputParams(struct soap *soap, struct ns1__glimmerInputParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__glimmerInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__glimmerInputParams * SOAP_FMAC4 soap_in_ns1__glimmerInputParams(struct soap *soap, const char *tag, struct ns1__glimmerInputParams *a, const char *type)
{
	size_t soap_flag_gencode = 1;
	size_t soap_flag_topology = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__glimmerInputParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__glimmerInputParams, sizeof(struct ns1__glimmerInputParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__glimmerInputParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gencode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "gencode", &a->gencode, "xsd:int"))
				{	soap_flag_gencode--;
					continue;
				}
			if (soap_flag_topology && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "topology", &a->topology, "xsd:string"))
				{	soap_flag_topology--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__glimmerInputParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__glimmerInputParams, 0, sizeof(struct ns1__glimmerInputParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_gencode > 0 || soap_flag_topology > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__genemarkhmmInputParams(struct soap *soap, struct ns1__genemarkhmmInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->title);
	soap_default_xsd__boolean(soap, &a->rbs);
	soap_default_xsd__boolean(soap, &a->list);
	soap_default_string(soap, &a->org);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__genemarkhmmInputParams(struct soap *soap, const struct ns1__genemarkhmmInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->title);
	soap_serialize_string(soap, &a->org);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__genemarkhmmInputParams(struct soap *soap, const struct ns1__genemarkhmmInputParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__genemarkhmmInputParams);
	if (soap_out_ns1__genemarkhmmInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__genemarkhmmInputParams(struct soap *soap, const char *tag, int id, const struct ns1__genemarkhmmInputParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__genemarkhmmInputParams), type))
		return soap->error;
	if (soap_out_string(soap, "title", -1, &a->title, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "rbs", -1, &a->rbs, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "list", -1, &a->list, ""))
		return soap->error;
	if (soap_out_string(soap, "org", -1, &a->org, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__genemarkhmmInputParams * SOAP_FMAC4 soap_get_ns1__genemarkhmmInputParams(struct soap *soap, struct ns1__genemarkhmmInputParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__genemarkhmmInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__genemarkhmmInputParams * SOAP_FMAC4 soap_in_ns1__genemarkhmmInputParams(struct soap *soap, const char *tag, struct ns1__genemarkhmmInputParams *a, const char *type)
{
	size_t soap_flag_title = 1;
	size_t soap_flag_rbs = 1;
	size_t soap_flag_list = 1;
	size_t soap_flag_org = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__genemarkhmmInputParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__genemarkhmmInputParams, sizeof(struct ns1__genemarkhmmInputParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__genemarkhmmInputParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_title && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "title", &a->title, "xsd:string"))
				{	soap_flag_title--;
					continue;
				}
			if (soap_flag_rbs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "rbs", &a->rbs, "xsd:boolean"))
				{	soap_flag_rbs--;
					continue;
				}
			if (soap_flag_list && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "list", &a->list, "xsd:boolean"))
				{	soap_flag_list--;
					continue;
				}
			if (soap_flag_org && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "org", &a->org, "xsd:string"))
				{	soap_flag_org--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__genemarkhmmInputParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__genemarkhmmInputParams, 0, sizeof(struct ns1__genemarkhmmInputParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_title > 0 || soap_flag_rbs > 0 || soap_flag_list > 0 || soap_flag_org > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__fetchBatchInputParams(struct soap *soap, struct ns1__fetchBatchInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->format);
	soap_default_string(soap, &a->style);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__fetchBatchInputParams(struct soap *soap, const struct ns1__fetchBatchInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->format);
	soap_serialize_string(soap, &a->style);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__fetchBatchInputParams(struct soap *soap, const struct ns1__fetchBatchInputParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__fetchBatchInputParams);
	if (soap_out_ns1__fetchBatchInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__fetchBatchInputParams(struct soap *soap, const char *tag, int id, const struct ns1__fetchBatchInputParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__fetchBatchInputParams), type))
		return soap->error;
	if (soap_out_string(soap, "format", -1, &a->format, ""))
		return soap->error;
	if (soap_out_string(soap, "style", -1, &a->style, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__fetchBatchInputParams * SOAP_FMAC4 soap_get_ns1__fetchBatchInputParams(struct soap *soap, struct ns1__fetchBatchInputParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__fetchBatchInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__fetchBatchInputParams * SOAP_FMAC4 soap_in_ns1__fetchBatchInputParams(struct soap *soap, const char *tag, struct ns1__fetchBatchInputParams *a, const char *type)
{
	size_t soap_flag_format = 1;
	size_t soap_flag_style = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__fetchBatchInputParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__fetchBatchInputParams, sizeof(struct ns1__fetchBatchInputParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__fetchBatchInputParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_format && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "format", &a->format, "xsd:string"))
				{	soap_flag_format--;
					continue;
				}
			if (soap_flag_style && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "style", &a->style, "xsd:string"))
				{	soap_flag_style--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__fetchBatchInputParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__fetchBatchInputParams, 0, sizeof(struct ns1__fetchBatchInputParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_format > 0 || soap_flag_style > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__fetchDataInputParams(struct soap *soap, struct ns1__fetchDataInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->format);
	soap_default_string(soap, &a->style);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__fetchDataInputParams(struct soap *soap, const struct ns1__fetchDataInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->format);
	soap_serialize_string(soap, &a->style);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__fetchDataInputParams(struct soap *soap, const struct ns1__fetchDataInputParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__fetchDataInputParams);
	if (soap_out_ns1__fetchDataInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__fetchDataInputParams(struct soap *soap, const char *tag, int id, const struct ns1__fetchDataInputParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__fetchDataInputParams), type))
		return soap->error;
	if (soap_out_string(soap, "format", -1, &a->format, ""))
		return soap->error;
	if (soap_out_string(soap, "style", -1, &a->style, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__fetchDataInputParams * SOAP_FMAC4 soap_get_ns1__fetchDataInputParams(struct soap *soap, struct ns1__fetchDataInputParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__fetchDataInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__fetchDataInputParams * SOAP_FMAC4 soap_in_ns1__fetchDataInputParams(struct soap *soap, const char *tag, struct ns1__fetchDataInputParams *a, const char *type)
{
	size_t soap_flag_format = 1;
	size_t soap_flag_style = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__fetchDataInputParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__fetchDataInputParams, sizeof(struct ns1__fetchDataInputParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__fetchDataInputParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_format && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "format", &a->format, "xsd:string"))
				{	soap_flag_format--;
					continue;
				}
			if (soap_flag_style && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "style", &a->style, "xsd:string"))
				{	soap_flag_style--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__fetchDataInputParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__fetchDataInputParams, 0, sizeof(struct ns1__fetchDataInputParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_format > 0 || soap_flag_style > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__clustalwInputParams(struct soap *soap, struct ns1__clustalwInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->alignment);
	soap_default_string(soap, &a->output);
	soap_default_string(soap, &a->matrix);
	soap_default_string(soap, &a->outorder);
	soap_default_int(soap, &a->ktup);
	soap_default_int(soap, &a->window);
	soap_default_int(soap, &a->gapopen);
	soap_default_float(soap, &a->gapext);
	soap_default_int(soap, &a->gapdist);
	soap_default_xsd__boolean(soap, &a->endgaps);
	soap_default_int(soap, &a->pairgap);
	soap_default_int(soap, &a->topdiags);
	soap_default_string(soap, &a->score);
	soap_default_xsd__boolean(soap, &a->tossgaps);
	soap_default_xsd__boolean(soap, &a->kimura);
	soap_default_string(soap, &a->outputtree);
	soap_default_xsd__boolean(soap, &a->tree);
	soap_default_xsd__boolean(soap, &a->quicktree);
	soap_default_xsd__boolean(soap, &a->align);
	soap_default_string(soap, &a->clustering);
	soap_default_int(soap, &a->numiter);
	soap_default_string(soap, &a->iteration);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__clustalwInputParams(struct soap *soap, const struct ns1__clustalwInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->alignment);
	soap_serialize_string(soap, &a->output);
	soap_serialize_string(soap, &a->matrix);
	soap_serialize_string(soap, &a->outorder);
	soap_embedded(soap, &a->ktup, SOAP_TYPE_int);
	soap_embedded(soap, &a->window, SOAP_TYPE_int);
	soap_embedded(soap, &a->gapopen, SOAP_TYPE_int);
	soap_embedded(soap, &a->gapdist, SOAP_TYPE_int);
	soap_embedded(soap, &a->pairgap, SOAP_TYPE_int);
	soap_embedded(soap, &a->topdiags, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->score);
	soap_serialize_string(soap, &a->outputtree);
	soap_serialize_string(soap, &a->clustering);
	soap_embedded(soap, &a->numiter, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->iteration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__clustalwInputParams(struct soap *soap, const struct ns1__clustalwInputParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__clustalwInputParams);
	if (soap_out_ns1__clustalwInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__clustalwInputParams(struct soap *soap, const char *tag, int id, const struct ns1__clustalwInputParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__clustalwInputParams), type))
		return soap->error;
	if (soap_out_string(soap, "alignment", -1, &a->alignment, ""))
		return soap->error;
	if (soap_out_string(soap, "output", -1, &a->output, ""))
		return soap->error;
	if (soap_out_string(soap, "matrix", -1, &a->matrix, ""))
		return soap->error;
	if (soap_out_string(soap, "outorder", -1, &a->outorder, ""))
		return soap->error;
	if (soap_out_int(soap, "ktup", -1, &a->ktup, ""))
		return soap->error;
	if (soap_out_int(soap, "window", -1, &a->window, ""))
		return soap->error;
	if (soap_out_int(soap, "gapopen", -1, &a->gapopen, ""))
		return soap->error;
	if (soap_out_float(soap, "gapext", -1, &a->gapext, ""))
		return soap->error;
	if (soap_out_int(soap, "gapdist", -1, &a->gapdist, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "endgaps", -1, &a->endgaps, ""))
		return soap->error;
	if (soap_out_int(soap, "pairgap", -1, &a->pairgap, ""))
		return soap->error;
	if (soap_out_int(soap, "topdiags", -1, &a->topdiags, ""))
		return soap->error;
	if (soap_out_string(soap, "score", -1, &a->score, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tossgaps", -1, &a->tossgaps, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "kimura", -1, &a->kimura, ""))
		return soap->error;
	if (soap_out_string(soap, "outputtree", -1, &a->outputtree, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tree", -1, &a->tree, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "quicktree", -1, &a->quicktree, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "align", -1, &a->align, ""))
		return soap->error;
	if (soap_out_string(soap, "clustering", -1, &a->clustering, ""))
		return soap->error;
	if (soap_out_int(soap, "numiter", -1, &a->numiter, ""))
		return soap->error;
	if (soap_out_string(soap, "iteration", -1, &a->iteration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__clustalwInputParams * SOAP_FMAC4 soap_get_ns1__clustalwInputParams(struct soap *soap, struct ns1__clustalwInputParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__clustalwInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__clustalwInputParams * SOAP_FMAC4 soap_in_ns1__clustalwInputParams(struct soap *soap, const char *tag, struct ns1__clustalwInputParams *a, const char *type)
{
	size_t soap_flag_alignment = 1;
	size_t soap_flag_output = 1;
	size_t soap_flag_matrix = 1;
	size_t soap_flag_outorder = 1;
	size_t soap_flag_ktup = 1;
	size_t soap_flag_window = 1;
	size_t soap_flag_gapopen = 1;
	size_t soap_flag_gapext = 1;
	size_t soap_flag_gapdist = 1;
	size_t soap_flag_endgaps = 1;
	size_t soap_flag_pairgap = 1;
	size_t soap_flag_topdiags = 1;
	size_t soap_flag_score = 1;
	size_t soap_flag_tossgaps = 1;
	size_t soap_flag_kimura = 1;
	size_t soap_flag_outputtree = 1;
	size_t soap_flag_tree = 1;
	size_t soap_flag_quicktree = 1;
	size_t soap_flag_align = 1;
	size_t soap_flag_clustering = 1;
	size_t soap_flag_numiter = 1;
	size_t soap_flag_iteration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__clustalwInputParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__clustalwInputParams, sizeof(struct ns1__clustalwInputParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__clustalwInputParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alignment && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "alignment", &a->alignment, "xsd:string"))
				{	soap_flag_alignment--;
					continue;
				}
			if (soap_flag_output && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "output", &a->output, "xsd:string"))
				{	soap_flag_output--;
					continue;
				}
			if (soap_flag_matrix && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "matrix", &a->matrix, "xsd:string"))
				{	soap_flag_matrix--;
					continue;
				}
			if (soap_flag_outorder && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "outorder", &a->outorder, "xsd:string"))
				{	soap_flag_outorder--;
					continue;
				}
			if (soap_flag_ktup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ktup", &a->ktup, "xsd:int"))
				{	soap_flag_ktup--;
					continue;
				}
			if (soap_flag_window && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "window", &a->window, "xsd:int"))
				{	soap_flag_window--;
					continue;
				}
			if (soap_flag_gapopen && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "gapopen", &a->gapopen, "xsd:int"))
				{	soap_flag_gapopen--;
					continue;
				}
			if (soap_flag_gapext && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "gapext", &a->gapext, "xsd:float"))
				{	soap_flag_gapext--;
					continue;
				}
			if (soap_flag_gapdist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "gapdist", &a->gapdist, "xsd:int"))
				{	soap_flag_gapdist--;
					continue;
				}
			if (soap_flag_endgaps && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "endgaps", &a->endgaps, "xsd:boolean"))
				{	soap_flag_endgaps--;
					continue;
				}
			if (soap_flag_pairgap && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "pairgap", &a->pairgap, "xsd:int"))
				{	soap_flag_pairgap--;
					continue;
				}
			if (soap_flag_topdiags && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "topdiags", &a->topdiags, "xsd:int"))
				{	soap_flag_topdiags--;
					continue;
				}
			if (soap_flag_score && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "score", &a->score, "xsd:string"))
				{	soap_flag_score--;
					continue;
				}
			if (soap_flag_tossgaps && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tossgaps", &a->tossgaps, "xsd:boolean"))
				{	soap_flag_tossgaps--;
					continue;
				}
			if (soap_flag_kimura && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "kimura", &a->kimura, "xsd:boolean"))
				{	soap_flag_kimura--;
					continue;
				}
			if (soap_flag_outputtree && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "outputtree", &a->outputtree, "xsd:string"))
				{	soap_flag_outputtree--;
					continue;
				}
			if (soap_flag_tree && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tree", &a->tree, "xsd:boolean"))
				{	soap_flag_tree--;
					continue;
				}
			if (soap_flag_quicktree && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "quicktree", &a->quicktree, "xsd:boolean"))
				{	soap_flag_quicktree--;
					continue;
				}
			if (soap_flag_align && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "align", &a->align, "xsd:boolean"))
				{	soap_flag_align--;
					continue;
				}
			if (soap_flag_clustering && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "clustering", &a->clustering, "xsd:string"))
				{	soap_flag_clustering--;
					continue;
				}
			if (soap_flag_numiter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numiter", &a->numiter, "xsd:int"))
				{	soap_flag_numiter--;
					continue;
				}
			if (soap_flag_iteration && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "iteration", &a->iteration, "xsd:string"))
				{	soap_flag_iteration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__clustalwInputParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__clustalwInputParams, 0, sizeof(struct ns1__clustalwInputParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alignment > 0 || soap_flag_output > 0 || soap_flag_matrix > 0 || soap_flag_outorder > 0 || soap_flag_ktup > 0 || soap_flag_window > 0 || soap_flag_gapopen > 0 || soap_flag_gapext > 0 || soap_flag_gapdist > 0 || soap_flag_endgaps > 0 || soap_flag_pairgap > 0 || soap_flag_topdiags > 0 || soap_flag_score > 0 || soap_flag_tossgaps > 0 || soap_flag_kimura > 0 || soap_flag_outputtree > 0 || soap_flag_tree > 0 || soap_flag_quicktree > 0 || soap_flag_align > 0 || soap_flag_clustering > 0 || soap_flag_numiter > 0 || soap_flag_iteration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__centroidfoldInputParams(struct soap *soap, struct ns1__centroidfoldInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->model);
	soap_default_int(soap, &a->gamma);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__centroidfoldInputParams(struct soap *soap, const struct ns1__centroidfoldInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->model);
	soap_embedded(soap, &a->gamma, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__centroidfoldInputParams(struct soap *soap, const struct ns1__centroidfoldInputParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__centroidfoldInputParams);
	if (soap_out_ns1__centroidfoldInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__centroidfoldInputParams(struct soap *soap, const char *tag, int id, const struct ns1__centroidfoldInputParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__centroidfoldInputParams), type))
		return soap->error;
	if (soap_out_string(soap, "model", -1, &a->model, ""))
		return soap->error;
	if (soap_out_int(soap, "gamma", -1, &a->gamma, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__centroidfoldInputParams * SOAP_FMAC4 soap_get_ns1__centroidfoldInputParams(struct soap *soap, struct ns1__centroidfoldInputParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__centroidfoldInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__centroidfoldInputParams * SOAP_FMAC4 soap_in_ns1__centroidfoldInputParams(struct soap *soap, const char *tag, struct ns1__centroidfoldInputParams *a, const char *type)
{
	size_t soap_flag_model = 1;
	size_t soap_flag_gamma = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__centroidfoldInputParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__centroidfoldInputParams, sizeof(struct ns1__centroidfoldInputParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__centroidfoldInputParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_model && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "model", &a->model, "xsd:string"))
				{	soap_flag_model--;
					continue;
				}
			if (soap_flag_gamma && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "gamma", &a->gamma, "xsd:int"))
				{	soap_flag_gamma--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__centroidfoldInputParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__centroidfoldInputParams, 0, sizeof(struct ns1__centroidfoldInputParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_model > 0 || soap_flag_gamma > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__blastInputParams(struct soap *soap, struct ns1__blastInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->p);
	soap_default_string(soap, &a->d);
	soap_default_string(soap, &a->server);
	soap_default_string(soap, &a->e);
	soap_default_string(soap, &a->m);
	soap_default_string(soap, &a->F);
	soap_default_int(soap, &a->G);
	soap_default_int(soap, &a->E);
	soap_default_string(soap, &a->X);
	soap_default_int(soap, &a->q);
	soap_default_int(soap, &a->r);
	soap_default_int(soap, &a->v);
	soap_default_int(soap, &a->b);
	soap_default_int(soap, &a->f);
	soap_default_xsd__boolean(soap, &a->g);
	soap_default_string(soap, &a->M);
	soap_default_int(soap, &a->W);
	soap_default_float(soap, &a->z);
	soap_default_int(soap, &a->K);
	soap_default_float(soap, &a->Y);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__blastInputParams(struct soap *soap, const struct ns1__blastInputParams *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->p);
	soap_serialize_string(soap, &a->d);
	soap_serialize_string(soap, &a->server);
	soap_serialize_string(soap, &a->e);
	soap_serialize_string(soap, &a->m);
	soap_serialize_string(soap, &a->F);
	soap_embedded(soap, &a->G, SOAP_TYPE_int);
	soap_embedded(soap, &a->E, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->X);
	soap_embedded(soap, &a->q, SOAP_TYPE_int);
	soap_embedded(soap, &a->r, SOAP_TYPE_int);
	soap_embedded(soap, &a->v, SOAP_TYPE_int);
	soap_embedded(soap, &a->b, SOAP_TYPE_int);
	soap_embedded(soap, &a->f, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->M);
	soap_embedded(soap, &a->W, SOAP_TYPE_int);
	soap_embedded(soap, &a->K, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__blastInputParams(struct soap *soap, const struct ns1__blastInputParams *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__blastInputParams);
	if (soap_out_ns1__blastInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__blastInputParams(struct soap *soap, const char *tag, int id, const struct ns1__blastInputParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__blastInputParams), type))
		return soap->error;
	if (soap_out_string(soap, "p", -1, &a->p, ""))
		return soap->error;
	if (soap_out_string(soap, "d", -1, &a->d, ""))
		return soap->error;
	if (soap_out_string(soap, "server", -1, &a->server, ""))
		return soap->error;
	if (soap_out_string(soap, "e", -1, &a->e, ""))
		return soap->error;
	if (soap_out_string(soap, "m", -1, &a->m, ""))
		return soap->error;
	if (soap_out_string(soap, "F", -1, &a->F, ""))
		return soap->error;
	if (soap_out_int(soap, "G", -1, &a->G, ""))
		return soap->error;
	if (soap_out_int(soap, "E", -1, &a->E, ""))
		return soap->error;
	if (soap_out_string(soap, "X", -1, &a->X, ""))
		return soap->error;
	if (soap_out_int(soap, "q", -1, &a->q, ""))
		return soap->error;
	if (soap_out_int(soap, "r", -1, &a->r, ""))
		return soap->error;
	if (soap_out_int(soap, "v", -1, &a->v, ""))
		return soap->error;
	if (soap_out_int(soap, "b", -1, &a->b, ""))
		return soap->error;
	if (soap_out_int(soap, "f", -1, &a->f, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "g", -1, &a->g, ""))
		return soap->error;
	if (soap_out_string(soap, "M", -1, &a->M, ""))
		return soap->error;
	if (soap_out_int(soap, "W", -1, &a->W, ""))
		return soap->error;
	if (soap_out_float(soap, "z", -1, &a->z, ""))
		return soap->error;
	if (soap_out_int(soap, "K", -1, &a->K, ""))
		return soap->error;
	if (soap_out_float(soap, "Y", -1, &a->Y, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__blastInputParams * SOAP_FMAC4 soap_get_ns1__blastInputParams(struct soap *soap, struct ns1__blastInputParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__blastInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__blastInputParams * SOAP_FMAC4 soap_in_ns1__blastInputParams(struct soap *soap, const char *tag, struct ns1__blastInputParams *a, const char *type)
{
	size_t soap_flag_p = 1;
	size_t soap_flag_d = 1;
	size_t soap_flag_server = 1;
	size_t soap_flag_e = 1;
	size_t soap_flag_m = 1;
	size_t soap_flag_F = 1;
	size_t soap_flag_G = 1;
	size_t soap_flag_E = 1;
	size_t soap_flag_X = 1;
	size_t soap_flag_q = 1;
	size_t soap_flag_r = 1;
	size_t soap_flag_v = 1;
	size_t soap_flag_b = 1;
	size_t soap_flag_f = 1;
	size_t soap_flag_g = 1;
	size_t soap_flag_M = 1;
	size_t soap_flag_W = 1;
	size_t soap_flag_z = 1;
	size_t soap_flag_K = 1;
	size_t soap_flag_Y = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__blastInputParams *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__blastInputParams, sizeof(struct ns1__blastInputParams), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__blastInputParams(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_p && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "p", &a->p, "xsd:string"))
				{	soap_flag_p--;
					continue;
				}
			if (soap_flag_d && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "d", &a->d, "xsd:string"))
				{	soap_flag_d--;
					continue;
				}
			if (soap_flag_server && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "server", &a->server, "xsd:string"))
				{	soap_flag_server--;
					continue;
				}
			if (soap_flag_e && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "e", &a->e, "xsd:string"))
				{	soap_flag_e--;
					continue;
				}
			if (soap_flag_m && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "m", &a->m, "xsd:string"))
				{	soap_flag_m--;
					continue;
				}
			if (soap_flag_F && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "F", &a->F, "xsd:string"))
				{	soap_flag_F--;
					continue;
				}
			if (soap_flag_G && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "G", &a->G, "xsd:int"))
				{	soap_flag_G--;
					continue;
				}
			if (soap_flag_E && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "E", &a->E, "xsd:int"))
				{	soap_flag_E--;
					continue;
				}
			if (soap_flag_X && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "X", &a->X, "xsd:string"))
				{	soap_flag_X--;
					continue;
				}
			if (soap_flag_q && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "q", &a->q, "xsd:int"))
				{	soap_flag_q--;
					continue;
				}
			if (soap_flag_r && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "r", &a->r, "xsd:int"))
				{	soap_flag_r--;
					continue;
				}
			if (soap_flag_v && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "v", &a->v, "xsd:int"))
				{	soap_flag_v--;
					continue;
				}
			if (soap_flag_b && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "b", &a->b, "xsd:int"))
				{	soap_flag_b--;
					continue;
				}
			if (soap_flag_f && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "f", &a->f, "xsd:int"))
				{	soap_flag_f--;
					continue;
				}
			if (soap_flag_g && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "g", &a->g, "xsd:boolean"))
				{	soap_flag_g--;
					continue;
				}
			if (soap_flag_M && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "M", &a->M, "xsd:string"))
				{	soap_flag_M--;
					continue;
				}
			if (soap_flag_W && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "W", &a->W, "xsd:int"))
				{	soap_flag_W--;
					continue;
				}
			if (soap_flag_z && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "z", &a->z, "xsd:float"))
				{	soap_flag_z--;
					continue;
				}
			if (soap_flag_K && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "K", &a->K, "xsd:int"))
				{	soap_flag_K--;
					continue;
				}
			if (soap_flag_Y && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "Y", &a->Y, "xsd:float"))
				{	soap_flag_Y--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__blastInputParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__blastInputParams, 0, sizeof(struct ns1__blastInputParams), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_p > 0 || soap_flag_d > 0 || soap_flag_server > 0 || soap_flag_e > 0 || soap_flag_m > 0 || soap_flag_F > 0 || soap_flag_G > 0 || soap_flag_E > 0 || soap_flag_X > 0 || soap_flag_q > 0 || soap_flag_r > 0 || soap_flag_v > 0 || soap_flag_b > 0 || soap_flag_f > 0 || soap_flag_g > 0 || soap_flag_M > 0 || soap_flag_W > 0 || soap_flag_z > 0 || soap_flag_K > 0 || soap_flag_Y > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__showBlastDBInputParams(struct soap *soap, struct ns1__showBlastDBInputParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__showBlastDBInputParams))
		soap_serialize_ns1__showBlastDBInputParams(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__showBlastDBInputParams(struct soap *soap, struct ns1__showBlastDBInputParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__showBlastDBInputParams);
	if (soap_out_PointerTons1__showBlastDBInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__showBlastDBInputParams(struct soap *soap, const char *tag, int id, struct ns1__showBlastDBInputParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__showBlastDBInputParams);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__showBlastDBInputParams(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__showBlastDBInputParams ** SOAP_FMAC4 soap_get_PointerTons1__showBlastDBInputParams(struct soap *soap, struct ns1__showBlastDBInputParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__showBlastDBInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__showBlastDBInputParams ** SOAP_FMAC4 soap_in_PointerTons1__showBlastDBInputParams(struct soap *soap, const char *tag, struct ns1__showBlastDBInputParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__showBlastDBInputParams **)soap_malloc(soap, sizeof(struct ns1__showBlastDBInputParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__showBlastDBInputParams(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__showBlastDBInputParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__showBlastDBInputParams, sizeof(struct ns1__showBlastDBInputParams), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RNAfoldInputParams(struct soap *soap, struct ns1__RNAfoldInputParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RNAfoldInputParams))
		soap_serialize_ns1__RNAfoldInputParams(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RNAfoldInputParams(struct soap *soap, struct ns1__RNAfoldInputParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__RNAfoldInputParams);
	if (soap_out_PointerTons1__RNAfoldInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RNAfoldInputParams(struct soap *soap, const char *tag, int id, struct ns1__RNAfoldInputParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RNAfoldInputParams);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__RNAfoldInputParams(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__RNAfoldInputParams ** SOAP_FMAC4 soap_get_PointerTons1__RNAfoldInputParams(struct soap *soap, struct ns1__RNAfoldInputParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RNAfoldInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__RNAfoldInputParams ** SOAP_FMAC4 soap_in_PointerTons1__RNAfoldInputParams(struct soap *soap, const char *tag, struct ns1__RNAfoldInputParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__RNAfoldInputParams **)soap_malloc(soap, sizeof(struct ns1__RNAfoldInputParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__RNAfoldInputParams(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__RNAfoldInputParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RNAfoldInputParams, sizeof(struct ns1__RNAfoldInputParams), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__wolfPsortInputParams(struct soap *soap, struct ns1__wolfPsortInputParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__wolfPsortInputParams))
		soap_serialize_ns1__wolfPsortInputParams(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__wolfPsortInputParams(struct soap *soap, struct ns1__wolfPsortInputParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__wolfPsortInputParams);
	if (soap_out_PointerTons1__wolfPsortInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__wolfPsortInputParams(struct soap *soap, const char *tag, int id, struct ns1__wolfPsortInputParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__wolfPsortInputParams);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__wolfPsortInputParams(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__wolfPsortInputParams ** SOAP_FMAC4 soap_get_PointerTons1__wolfPsortInputParams(struct soap *soap, struct ns1__wolfPsortInputParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__wolfPsortInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__wolfPsortInputParams ** SOAP_FMAC4 soap_in_PointerTons1__wolfPsortInputParams(struct soap *soap, const char *tag, struct ns1__wolfPsortInputParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__wolfPsortInputParams **)soap_malloc(soap, sizeof(struct ns1__wolfPsortInputParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__wolfPsortInputParams(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__wolfPsortInputParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__wolfPsortInputParams, sizeof(struct ns1__wolfPsortInputParams), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__weblogoInputParams(struct soap *soap, struct ns1__weblogoInputParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__weblogoInputParams))
		soap_serialize_ns1__weblogoInputParams(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__weblogoInputParams(struct soap *soap, struct ns1__weblogoInputParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__weblogoInputParams);
	if (soap_out_PointerTons1__weblogoInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__weblogoInputParams(struct soap *soap, const char *tag, int id, struct ns1__weblogoInputParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__weblogoInputParams);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__weblogoInputParams(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__weblogoInputParams ** SOAP_FMAC4 soap_get_PointerTons1__weblogoInputParams(struct soap *soap, struct ns1__weblogoInputParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__weblogoInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__weblogoInputParams ** SOAP_FMAC4 soap_in_PointerTons1__weblogoInputParams(struct soap *soap, const char *tag, struct ns1__weblogoInputParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__weblogoInputParams **)soap_malloc(soap, sizeof(struct ns1__weblogoInputParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__weblogoInputParams(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__weblogoInputParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__weblogoInputParams, sizeof(struct ns1__weblogoInputParams), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__tRNAscanInputParams(struct soap *soap, struct ns1__tRNAscanInputParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__tRNAscanInputParams))
		soap_serialize_ns1__tRNAscanInputParams(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__tRNAscanInputParams(struct soap *soap, struct ns1__tRNAscanInputParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__tRNAscanInputParams);
	if (soap_out_PointerTons1__tRNAscanInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__tRNAscanInputParams(struct soap *soap, const char *tag, int id, struct ns1__tRNAscanInputParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__tRNAscanInputParams);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__tRNAscanInputParams(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__tRNAscanInputParams ** SOAP_FMAC4 soap_get_PointerTons1__tRNAscanInputParams(struct soap *soap, struct ns1__tRNAscanInputParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__tRNAscanInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__tRNAscanInputParams ** SOAP_FMAC4 soap_in_PointerTons1__tRNAscanInputParams(struct soap *soap, const char *tag, struct ns1__tRNAscanInputParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__tRNAscanInputParams **)soap_malloc(soap, sizeof(struct ns1__tRNAscanInputParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__tRNAscanInputParams(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__tRNAscanInputParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__tRNAscanInputParams, sizeof(struct ns1__tRNAscanInputParams), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__tcoffeeInputParams(struct soap *soap, struct ns1__tcoffeeInputParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__tcoffeeInputParams))
		soap_serialize_ns1__tcoffeeInputParams(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__tcoffeeInputParams(struct soap *soap, struct ns1__tcoffeeInputParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__tcoffeeInputParams);
	if (soap_out_PointerTons1__tcoffeeInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__tcoffeeInputParams(struct soap *soap, const char *tag, int id, struct ns1__tcoffeeInputParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__tcoffeeInputParams);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__tcoffeeInputParams(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__tcoffeeInputParams ** SOAP_FMAC4 soap_get_PointerTons1__tcoffeeInputParams(struct soap *soap, struct ns1__tcoffeeInputParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__tcoffeeInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__tcoffeeInputParams ** SOAP_FMAC4 soap_in_PointerTons1__tcoffeeInputParams(struct soap *soap, const char *tag, struct ns1__tcoffeeInputParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__tcoffeeInputParams **)soap_malloc(soap, sizeof(struct ns1__tcoffeeInputParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__tcoffeeInputParams(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__tcoffeeInputParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__tcoffeeInputParams, sizeof(struct ns1__tcoffeeInputParams), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ssearchInputParams(struct soap *soap, struct ns1__ssearchInputParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ssearchInputParams))
		soap_serialize_ns1__ssearchInputParams(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ssearchInputParams(struct soap *soap, struct ns1__ssearchInputParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ssearchInputParams);
	if (soap_out_PointerTons1__ssearchInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ssearchInputParams(struct soap *soap, const char *tag, int id, struct ns1__ssearchInputParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ssearchInputParams);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ssearchInputParams(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ssearchInputParams ** SOAP_FMAC4 soap_get_PointerTons1__ssearchInputParams(struct soap *soap, struct ns1__ssearchInputParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ssearchInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__ssearchInputParams ** SOAP_FMAC4 soap_in_PointerTons1__ssearchInputParams(struct soap *soap, const char *tag, struct ns1__ssearchInputParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ssearchInputParams **)soap_malloc(soap, sizeof(struct ns1__ssearchInputParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ssearchInputParams(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ssearchInputParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ssearchInputParams, sizeof(struct ns1__ssearchInputParams), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__psortbInputParams(struct soap *soap, struct ns1__psortbInputParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__psortbInputParams))
		soap_serialize_ns1__psortbInputParams(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__psortbInputParams(struct soap *soap, struct ns1__psortbInputParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__psortbInputParams);
	if (soap_out_PointerTons1__psortbInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__psortbInputParams(struct soap *soap, const char *tag, int id, struct ns1__psortbInputParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__psortbInputParams);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__psortbInputParams(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__psortbInputParams ** SOAP_FMAC4 soap_get_PointerTons1__psortbInputParams(struct soap *soap, struct ns1__psortbInputParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__psortbInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__psortbInputParams ** SOAP_FMAC4 soap_in_PointerTons1__psortbInputParams(struct soap *soap, const char *tag, struct ns1__psortbInputParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__psortbInputParams **)soap_malloc(soap, sizeof(struct ns1__psortbInputParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__psortbInputParams(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__psortbInputParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__psortbInputParams, sizeof(struct ns1__psortbInputParams), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__psortInputParams(struct soap *soap, struct ns1__psortInputParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__psortInputParams))
		soap_serialize_ns1__psortInputParams(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__psortInputParams(struct soap *soap, struct ns1__psortInputParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__psortInputParams);
	if (soap_out_PointerTons1__psortInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__psortInputParams(struct soap *soap, const char *tag, int id, struct ns1__psortInputParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__psortInputParams);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__psortInputParams(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__psortInputParams ** SOAP_FMAC4 soap_get_PointerTons1__psortInputParams(struct soap *soap, struct ns1__psortInputParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__psortInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__psortInputParams ** SOAP_FMAC4 soap_in_PointerTons1__psortInputParams(struct soap *soap, const char *tag, struct ns1__psortInputParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__psortInputParams **)soap_malloc(soap, sizeof(struct ns1__psortInputParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__psortInputParams(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__psortInputParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__psortInputParams, sizeof(struct ns1__psortInputParams), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__phobiusInputParams(struct soap *soap, struct ns1__phobiusInputParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__phobiusInputParams))
		soap_serialize_ns1__phobiusInputParams(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__phobiusInputParams(struct soap *soap, struct ns1__phobiusInputParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__phobiusInputParams);
	if (soap_out_PointerTons1__phobiusInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__phobiusInputParams(struct soap *soap, const char *tag, int id, struct ns1__phobiusInputParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__phobiusInputParams);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__phobiusInputParams(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__phobiusInputParams ** SOAP_FMAC4 soap_get_PointerTons1__phobiusInputParams(struct soap *soap, struct ns1__phobiusInputParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__phobiusInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__phobiusInputParams ** SOAP_FMAC4 soap_in_PointerTons1__phobiusInputParams(struct soap *soap, const char *tag, struct ns1__phobiusInputParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__phobiusInputParams **)soap_malloc(soap, sizeof(struct ns1__phobiusInputParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__phobiusInputParams(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__phobiusInputParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__phobiusInputParams, sizeof(struct ns1__phobiusInputParams), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__muscleInputParams(struct soap *soap, struct ns1__muscleInputParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__muscleInputParams))
		soap_serialize_ns1__muscleInputParams(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__muscleInputParams(struct soap *soap, struct ns1__muscleInputParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__muscleInputParams);
	if (soap_out_PointerTons1__muscleInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__muscleInputParams(struct soap *soap, const char *tag, int id, struct ns1__muscleInputParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__muscleInputParams);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__muscleInputParams(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__muscleInputParams ** SOAP_FMAC4 soap_get_PointerTons1__muscleInputParams(struct soap *soap, struct ns1__muscleInputParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__muscleInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__muscleInputParams ** SOAP_FMAC4 soap_in_PointerTons1__muscleInputParams(struct soap *soap, const char *tag, struct ns1__muscleInputParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__muscleInputParams **)soap_malloc(soap, sizeof(struct ns1__muscleInputParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__muscleInputParams(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__muscleInputParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__muscleInputParams, sizeof(struct ns1__muscleInputParams), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mafftInputParams(struct soap *soap, struct ns1__mafftInputParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mafftInputParams))
		soap_serialize_ns1__mafftInputParams(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mafftInputParams(struct soap *soap, struct ns1__mafftInputParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mafftInputParams);
	if (soap_out_PointerTons1__mafftInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mafftInputParams(struct soap *soap, const char *tag, int id, struct ns1__mafftInputParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mafftInputParams);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mafftInputParams(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mafftInputParams ** SOAP_FMAC4 soap_get_PointerTons1__mafftInputParams(struct soap *soap, struct ns1__mafftInputParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mafftInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__mafftInputParams ** SOAP_FMAC4 soap_in_PointerTons1__mafftInputParams(struct soap *soap, const char *tag, struct ns1__mafftInputParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mafftInputParams **)soap_malloc(soap, sizeof(struct ns1__mafftInputParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mafftInputParams(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mafftInputParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mafftInputParams, sizeof(struct ns1__mafftInputParams), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__kalignInputParams(struct soap *soap, struct ns1__kalignInputParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__kalignInputParams))
		soap_serialize_ns1__kalignInputParams(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__kalignInputParams(struct soap *soap, struct ns1__kalignInputParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__kalignInputParams);
	if (soap_out_PointerTons1__kalignInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__kalignInputParams(struct soap *soap, const char *tag, int id, struct ns1__kalignInputParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__kalignInputParams);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__kalignInputParams(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__kalignInputParams ** SOAP_FMAC4 soap_get_PointerTons1__kalignInputParams(struct soap *soap, struct ns1__kalignInputParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__kalignInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__kalignInputParams ** SOAP_FMAC4 soap_in_PointerTons1__kalignInputParams(struct soap *soap, const char *tag, struct ns1__kalignInputParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__kalignInputParams **)soap_malloc(soap, sizeof(struct ns1__kalignInputParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__kalignInputParams(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__kalignInputParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__kalignInputParams, sizeof(struct ns1__kalignInputParams), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__glimmerInputParams(struct soap *soap, struct ns1__glimmerInputParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__glimmerInputParams))
		soap_serialize_ns1__glimmerInputParams(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__glimmerInputParams(struct soap *soap, struct ns1__glimmerInputParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__glimmerInputParams);
	if (soap_out_PointerTons1__glimmerInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__glimmerInputParams(struct soap *soap, const char *tag, int id, struct ns1__glimmerInputParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__glimmerInputParams);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__glimmerInputParams(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__glimmerInputParams ** SOAP_FMAC4 soap_get_PointerTons1__glimmerInputParams(struct soap *soap, struct ns1__glimmerInputParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__glimmerInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__glimmerInputParams ** SOAP_FMAC4 soap_in_PointerTons1__glimmerInputParams(struct soap *soap, const char *tag, struct ns1__glimmerInputParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__glimmerInputParams **)soap_malloc(soap, sizeof(struct ns1__glimmerInputParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__glimmerInputParams(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__glimmerInputParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__glimmerInputParams, sizeof(struct ns1__glimmerInputParams), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__genemarkhmmInputParams(struct soap *soap, struct ns1__genemarkhmmInputParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__genemarkhmmInputParams))
		soap_serialize_ns1__genemarkhmmInputParams(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__genemarkhmmInputParams(struct soap *soap, struct ns1__genemarkhmmInputParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__genemarkhmmInputParams);
	if (soap_out_PointerTons1__genemarkhmmInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__genemarkhmmInputParams(struct soap *soap, const char *tag, int id, struct ns1__genemarkhmmInputParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__genemarkhmmInputParams);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__genemarkhmmInputParams(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__genemarkhmmInputParams ** SOAP_FMAC4 soap_get_PointerTons1__genemarkhmmInputParams(struct soap *soap, struct ns1__genemarkhmmInputParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__genemarkhmmInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__genemarkhmmInputParams ** SOAP_FMAC4 soap_in_PointerTons1__genemarkhmmInputParams(struct soap *soap, const char *tag, struct ns1__genemarkhmmInputParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__genemarkhmmInputParams **)soap_malloc(soap, sizeof(struct ns1__genemarkhmmInputParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__genemarkhmmInputParams(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__genemarkhmmInputParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__genemarkhmmInputParams, sizeof(struct ns1__genemarkhmmInputParams), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__fetchBatchInputParams(struct soap *soap, struct ns1__fetchBatchInputParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__fetchBatchInputParams))
		soap_serialize_ns1__fetchBatchInputParams(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__fetchBatchInputParams(struct soap *soap, struct ns1__fetchBatchInputParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__fetchBatchInputParams);
	if (soap_out_PointerTons1__fetchBatchInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__fetchBatchInputParams(struct soap *soap, const char *tag, int id, struct ns1__fetchBatchInputParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__fetchBatchInputParams);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__fetchBatchInputParams(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__fetchBatchInputParams ** SOAP_FMAC4 soap_get_PointerTons1__fetchBatchInputParams(struct soap *soap, struct ns1__fetchBatchInputParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__fetchBatchInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__fetchBatchInputParams ** SOAP_FMAC4 soap_in_PointerTons1__fetchBatchInputParams(struct soap *soap, const char *tag, struct ns1__fetchBatchInputParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__fetchBatchInputParams **)soap_malloc(soap, sizeof(struct ns1__fetchBatchInputParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__fetchBatchInputParams(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__fetchBatchInputParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__fetchBatchInputParams, sizeof(struct ns1__fetchBatchInputParams), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__fetchDataInputParams(struct soap *soap, struct ns1__fetchDataInputParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__fetchDataInputParams))
		soap_serialize_ns1__fetchDataInputParams(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__fetchDataInputParams(struct soap *soap, struct ns1__fetchDataInputParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__fetchDataInputParams);
	if (soap_out_PointerTons1__fetchDataInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__fetchDataInputParams(struct soap *soap, const char *tag, int id, struct ns1__fetchDataInputParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__fetchDataInputParams);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__fetchDataInputParams(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__fetchDataInputParams ** SOAP_FMAC4 soap_get_PointerTons1__fetchDataInputParams(struct soap *soap, struct ns1__fetchDataInputParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__fetchDataInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__fetchDataInputParams ** SOAP_FMAC4 soap_in_PointerTons1__fetchDataInputParams(struct soap *soap, const char *tag, struct ns1__fetchDataInputParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__fetchDataInputParams **)soap_malloc(soap, sizeof(struct ns1__fetchDataInputParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__fetchDataInputParams(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__fetchDataInputParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__fetchDataInputParams, sizeof(struct ns1__fetchDataInputParams), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__clustalwInputParams(struct soap *soap, struct ns1__clustalwInputParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__clustalwInputParams))
		soap_serialize_ns1__clustalwInputParams(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__clustalwInputParams(struct soap *soap, struct ns1__clustalwInputParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__clustalwInputParams);
	if (soap_out_PointerTons1__clustalwInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__clustalwInputParams(struct soap *soap, const char *tag, int id, struct ns1__clustalwInputParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__clustalwInputParams);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__clustalwInputParams(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__clustalwInputParams ** SOAP_FMAC4 soap_get_PointerTons1__clustalwInputParams(struct soap *soap, struct ns1__clustalwInputParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__clustalwInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__clustalwInputParams ** SOAP_FMAC4 soap_in_PointerTons1__clustalwInputParams(struct soap *soap, const char *tag, struct ns1__clustalwInputParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__clustalwInputParams **)soap_malloc(soap, sizeof(struct ns1__clustalwInputParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__clustalwInputParams(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__clustalwInputParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__clustalwInputParams, sizeof(struct ns1__clustalwInputParams), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__centroidfoldInputParams(struct soap *soap, struct ns1__centroidfoldInputParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__centroidfoldInputParams))
		soap_serialize_ns1__centroidfoldInputParams(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__centroidfoldInputParams(struct soap *soap, struct ns1__centroidfoldInputParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__centroidfoldInputParams);
	if (soap_out_PointerTons1__centroidfoldInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__centroidfoldInputParams(struct soap *soap, const char *tag, int id, struct ns1__centroidfoldInputParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__centroidfoldInputParams);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__centroidfoldInputParams(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__centroidfoldInputParams ** SOAP_FMAC4 soap_get_PointerTons1__centroidfoldInputParams(struct soap *soap, struct ns1__centroidfoldInputParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__centroidfoldInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__centroidfoldInputParams ** SOAP_FMAC4 soap_in_PointerTons1__centroidfoldInputParams(struct soap *soap, const char *tag, struct ns1__centroidfoldInputParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__centroidfoldInputParams **)soap_malloc(soap, sizeof(struct ns1__centroidfoldInputParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__centroidfoldInputParams(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__centroidfoldInputParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__centroidfoldInputParams, sizeof(struct ns1__centroidfoldInputParams), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__blastInputParams(struct soap *soap, struct ns1__blastInputParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__blastInputParams))
		soap_serialize_ns1__blastInputParams(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__blastInputParams(struct soap *soap, struct ns1__blastInputParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__blastInputParams);
	if (soap_out_PointerTons1__blastInputParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__blastInputParams(struct soap *soap, const char *tag, int id, struct ns1__blastInputParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__blastInputParams);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__blastInputParams(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__blastInputParams ** SOAP_FMAC4 soap_get_PointerTons1__blastInputParams(struct soap *soap, struct ns1__blastInputParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__blastInputParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__blastInputParams ** SOAP_FMAC4 soap_in_PointerTons1__blastInputParams(struct soap *soap, const char *tag, struct ns1__blastInputParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__blastInputParams **)soap_malloc(soap, sizeof(struct ns1__blastInputParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__blastInputParams(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__blastInputParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__blastInputParams, sizeof(struct ns1__blastInputParams), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
